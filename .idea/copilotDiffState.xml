<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Gemfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Gemfile" />
              <option name="originalContent" value="source &quot;https://rubygems.org&quot;&#10;&#10;# Bundle edge Rails instead: gem &quot;rails&quot;, github: &quot;rails/rails&quot;, branch: &quot;main&quot;&#10;gem &quot;rails&quot;, &quot;~&gt; 8.0.2&quot;&#10;# Use sqlite3 as the database for Active Record&#10;# gem &quot;sqlite3&quot;, &quot;&gt;= 2.1&quot;&#10;# Use PostgreSQL as the database for Active Record&#10;gem &quot;pg&quot;&#10;# Use the Puma web server [https://github.com/puma/puma]&#10;gem &quot;puma&quot;, &quot;&gt;= 5.0&quot;&#10;# Build JSON APIs with ease [https://github.com/rails/jbuilder]&#10;# gem &quot;jbuilder&quot;&#10;&#10;# Use Active Model has_secure_password [https://guides.rubyonrails.org/active_model_basics.html#securepassword]&#10;# gem &quot;bcrypt&quot;, &quot;~&gt; 3.1.7&quot;&#10;&#10;# Windows does not include zoneinfo files, so bundle the tzinfo-data gem&#10;gem &quot;tzinfo-data&quot;, platforms: %i[ windows jruby ]&#10;&#10;# Use the database-backed adapters for Rails.cache, Active Job, and Action Cable&#10;gem &quot;solid_cache&quot;&#10;gem &quot;solid_queue&quot;&#10;gem &quot;solid_cable&quot;&#10;&#10;# Reduces boot times through caching; required in config/boot.rb&#10;gem &quot;bootsnap&quot;, require: false&#10;&#10;# Deploy this application anywhere as a Docker container [https://kamal-deploy.org]&#10;gem &quot;kamal&quot;, require: false&#10;&#10;# Add HTTP asset caching/compression and X-Sendfile acceleration to Puma [https://github.com/basecamp/thruster/]&#10;gem &quot;thruster&quot;, require: false&#10;&#10;# Use Active Storage variants [https://guides.rubyonrails.org/active_storage_overview.html#transforming-images]&#10;# gem &quot;image_processing&quot;, &quot;~&gt; 1.2&quot;&#10;&#10;# Use Rack CORS for handling Cross-Origin Resource Sharing (CORS), making cross-origin Ajax possible&#10;# gem &quot;rack-cors&quot;&#10;&#10;group :development, :test do&#10;  # See https://guides.rubyonrails.org/debugging_rails_applications.html#debugging-with-the-debug-gem&#10;  gem &quot;debug&quot;, platforms: %i[ mri windows ], require: &quot;debug/prelude&quot;&#10;&#10;  # Remove estas linhas incompatíveis com Ruby 3.4+:&#10;  # gem &quot;debase&quot;&#10;  # gem &quot;ruby-debug-ide&quot;&#10;&#10;  # Static analysis for security vulnerabilities [https://brakemanscanner.org/]&#10;  gem &quot;brakeman&quot;, require: false&#10;&#10;  # Omakase Ruby styling [https://github.com/rails/rubocop-rails-omakase/]&#10;  gem &quot;rubocop-rails-omakase&quot;, require: false&#10;end&#10;" />
              <option name="updatedContent" value="source &quot;https://rubygems.org&quot;&#10;&#10;# Bundle edge Rails instead: gem &quot;rails&quot;, github: &quot;rails/rails&quot;, branch: &quot;main&quot;&#10;gem &quot;rails&quot;, &quot;~&gt; 8.0.2&quot;&#10;# Use sqlite3 as the database for Active Record&#10;# gem &quot;sqlite3&quot;, &quot;&gt;= 2.1&quot;&#10;# Use PostgreSQL as the database for Active Record&#10;gem &quot;pg&quot;&#10;# Use the Puma web server [https://github.com/puma/puma]&#10;gem &quot;puma&quot;, &quot;&gt;= 5.0&quot;&#10;# Build JSON APIs with ease [https://github.com/rails/jbuilder]&#10;# gem &quot;jbuilder&quot;&#10;&#10;# Use Active Model has_secure_password [https://guides.rubyonrails.org/active_model_basics.html#securepassword]&#10;# gem &quot;bcrypt&quot;, &quot;~&gt; 3.1.7&quot;&#10;&#10;# Windows does not include zoneinfo files, so bundle the tzinfo-data gem&#10;gem &quot;tzinfo-data&quot;, platforms: %i[ windows jruby ]&#10;&#10;# Use the database-backed adapters for Rails.cache, Active Job, and Action Cable&#10;gem &quot;solid_cache&quot;&#10;gem &quot;solid_queue&quot;&#10;gem &quot;solid_cable&quot;&#10;&#10;# Reduces boot times through caching; required in config/boot.rb&#10;gem &quot;bootsnap&quot;, require: false&#10;&#10;# Deploy this application anywhere as a Docker container [https://kamal-deploy.org]&#10;gem &quot;kamal&quot;, require: false&#10;&#10;# Add HTTP asset caching/compression and X-Sendfile acceleration to Puma [https://github.com/basecamp/thruster/]&#10;gem &quot;thruster&quot;, require: false&#10;&#10;# Use Active Storage variants [https://guides.rubyonrails.org/active_storage_overview.html#transforming-images]&#10;# gem &quot;image_processing&quot;, &quot;~&gt; 1.2&quot;&#10;&#10;# Use Rack CORS for handling Cross-Origin Resource Sharing (CORS), making cross-origin Ajax possible&#10;# gem &quot;rack-cors&quot;&#10;&#10;# gem 'jwt'&#10;&#10;group :development, :test do&#10;  # See https://guides.rubyonrails.org/debugging_rails_applications.html#debugging-with-the-debug-gem&#10;  gem &quot;debug&quot;, platforms: %i[ mri windows ], require: &quot;debug/prelude&quot;&#10;&#10;  # Remove estas linhas incompatíveis com Ruby 3.4+:&#10;  # gem &quot;debase&quot;&#10;  # gem &quot;ruby-debug-ide&quot;&#10;&#10;  # Static analysis for security vulnerabilities [https://brakemanscanner.org/]&#10;  gem &quot;brakeman&quot;, require: false&#10;&#10;  # Omakase Ruby styling [https://github.com/rails/rubocop-rails-omakase/]&#10;  gem &quot;rubocop-rails-omakase&quot;, require: false&#10;end" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/controllers/app_controller.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/controllers/app_controller.rb" />
              <option name="originalContent" value="class AppController &lt; ApplicationController&#10;  # POST /app/token&#10;  def token&#10;    # Extrai o header Authorization&#10;    auth_header = request.headers['Authorization']&#10;    if auth_header.blank? || !auth_header.start_with?('Basic ')&#10;      render json: { error: 'Authorization header inválido' }, status: :unauthorized and return&#10;    end&#10;&#10;    # Decodifica o Basic Auth&#10;    base64_credentials = auth_header.split(' ', 2).last&#10;    credentials = Base64.decode64(base64_credentials).split(':', 2)&#10;    username = credentials[0]&#10;    password = credentials[1]&#10;&#10;    # Busca o usuário no banco&#10;    user = TbCustomers.find_by(username: username)&#10;    if user.nil? || user.password != password&#10;      render json: { error: 'Usuário ou senha inválidos' }, status: :unauthorized and return&#10;    end&#10;&#10;    # Recupera a role do usuário&#10;    role = user.role&#10;&#10;    render json: { username: username, role: role }&#10;  end&#10;end&#10;" />
              <option name="updatedContent" value="class AppController &lt; ApplicationController&#10;  # POST /app/token&#10;  def token&#10;    # Extrai o header Authorization&#10;    auth_header = request.headers['Authorization']&#10;    if auth_header.blank? || !auth_header.start_with?('Basic ')&#10;      render json: { error: 'Authorization header inválido' }, status: :unauthorized and return&#10;    end&#10;&#10;    # Decodifica o Basic Auth&#10;    base64_credentials = auth_header.split(' ', 2).last&#10;    credentials = Base64.decode64(base64_credentials).split(':', 2)&#10;    username = credentials[0]&#10;    password = credentials[1]&#10;&#10;    # Busca o usuário no banco&#10;    user = TbCustomers.find_by(username: username)&#10;    if user.nil? || user.password != password&#10;      render json: { error: 'Usuário ou senha inválidos' }, status: :unauthorized and return&#10;    end&#10;&#10;    # Recupera a role do usuário&#10;    role = user.role&#10;&#10;    # Define o scope baseado na role&#10;    scope = case role&#10;            when 'admin' then 'admin_scope'&#10;            when 'user' then 'user_scope'&#10;            else 'default_scope'&#10;            end&#10;&#10;    # Gera o JWT&#10;    payload = {&#10;      sub: user.id,&#10;      username: user.username,&#10;      role: role,&#10;      scope: scope,&#10;      exp: 24.hours.from_now.to_i&#10;    }&#10;    secret = Rails.application.secret_key_base&#10;    token = JWT.encode(payload, secret, 'HS256')&#10;&#10;    render json: { token: token }&#10;  end&#10;end" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/controllers/tb_policies_controller.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/controllers/tb_policies_controller.rb" />
              <option name="originalContent" value="class TbPoliciesController &lt; ApplicationController&#10;  before_action :set_tb_policy, only: %i[ show edit update destroy ]&#10;&#10;  # GET /tb_policies&#10;  def index&#10;&#10;  end&#10;&#10;  # GET /tb_policies/1&#10;  def show&#10;&#10;  end&#10;&#10;  # GET /tb_policies/new&#10;  def new&#10;&#10;  end&#10;&#10;  # GET /tb_policies/1/edit&#10;  def edit&#10;&#10;  end&#10;&#10;  # POST /tb_policies&#10;  def create&#10;&#10;  end&#10;&#10;  # PATCH/PUT /tb_policies/1&#10;  def update&#10;&#10;  end&#10;&#10;  # DELETE /tb_policies/1&#10;  def destroy&#10;&#10;  end&#10;&#10;  private&#10;    # Use callbacks to share common setup or constraints between actions.&#10;    def set_tb_policy&#10;      @tb_policy = TbPolicy.find(params.expect(:id))&#10;    end&#10;&#10;    # Only allow a list of trusted parameters through.&#10;    def tb_policy_params&#10;      params.expect(tb_policy: [ :policy_number, :tb_customer_id, :start_date, :end_date, :status ])&#10;    end&#10;end&#10;" />
              <option name="updatedContent" value="class TbPoliciesController &lt; ApplicationController&#10;  before_action :set_tb_policy, only: %i[ show edit update destroy ]&#10;&#10;  # GET /tb_policies&#10;  def index&#10;    @tb_policies = PoliciesService.all&#10;  end&#10;&#10;  # GET /tb_policies/1&#10;  def show&#10;    # @tb_policy já está setado pelo before_action&#10;  end&#10;&#10;  # GET /tb_policies/new&#10;  def new&#10;    @tb_policy = TbPolicy.new&#10;  end&#10;&#10;  # GET /tb_policies/1/edit&#10;  def edit&#10;    # @tb_policy já está setado pelo before_action&#10;  end&#10;&#10;  # POST /tb_policies&#10;  def create&#10;    @tb_policy = PoliciesService.create(tb_policy_params)&#10;    if @tb_policy.persisted?&#10;      redirect_to @tb_policy, notice: 'Policy criada com sucesso.'&#10;    else&#10;      render :new, status: :unprocessable_entity&#10;    end&#10;  end&#10;&#10;  # PATCH/PUT /tb_policies/1&#10;  def update&#10;    if PoliciesService.update(@tb_policy, tb_policy_params)&#10;      redirect_to @tb_policy, notice: 'Policy atualizada com sucesso.'&#10;    else&#10;      render :edit, status: :unprocessable_entity&#10;    end&#10;  end&#10;&#10;  # DELETE /tb_policies/1&#10;  def destroy&#10;    PoliciesService.destroy(@tb_policy)&#10;    redirect_to tb_policies_url, notice: 'Policy removida com sucesso.'&#10;  end&#10;&#10;  private&#10;    # Use callbacks to share common setup or constraints between actions.&#10;    def set_tb_policy&#10;      @tb_policy = PoliciesService.find(params[:id])&#10;    end&#10;&#10;    # Only allow a list of trusted parameters through.&#10;    def tb_policy_params&#10;      params.require(:tb_policy).permit(:nome, :descricao, :valor)&#10;    end&#10;end" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/middleware/jwt_auth_middleware.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/middleware/jwt_auth_middleware.rb" />
              <option name="originalContent" value="class JwtAuthMiddleware&#10;  def initialize(app)&#10;    @app = app&#10;  end&#10;&#10;  def call(env)&#10;    req = Rack::Request.new(env)&#10;    auth_header = req.get_header(&quot;HTTP_AUTHORIZATION&quot;)&#10;&#10;    if auth_header.nil?&#10;      return [401, { &quot;Content-Type&quot; =&gt; &quot;application/json&quot; }, [{ error: &quot;Authorization header ausente&quot; }.to_json]]&#10;    end&#10;&#10;    if auth_header.start_with?(&quot;Basic &quot;)&#10;      # Permite passar para endpoints que usam Basic Auth (ex: /app/token)&#10;      @app.call(env)&#10;    elsif auth_header.start_with?(&quot;Bearer &quot;)&#10;      token = auth_header.split(&quot; &quot;, 2).last&#10;&#10;      begin&#10;        secret = Rails.application.secret_key_base&#10;        decoded = JWT.decode(token, secret, false, { algorithm: &quot;HS256&quot; })&#10;        payload = decoded[0]&#10;        unless payload[&quot;scope&quot;] == &quot;pp&quot;&#10;          return [403, { &quot;Content-Type&quot; =&gt; &quot;application/json&quot; }, [{ error: &quot;Scope não autorizado&quot; }.to_json]]&#10;        end&#10;        env[&quot;jwt.payload&quot;] = payload&#10;      rescue JWT::DecodeError =&gt; e&#10;        return [401, { &quot;Content-Type&quot; =&gt; &quot;application/json&quot; }, [{ error: &quot;Token inválido&quot;, message: e.message }.to_json]]&#10;      end&#10;      @app.call(env)&#10;    else&#10;      [401, { &quot;Content-Type&quot; =&gt; &quot;application/json&quot; }, [{ error: &quot;Tipo de Authorization não suportado&quot; }.to_json]]&#10;    end&#10;&#10;  end&#10;end&#10;" />
              <option name="updatedContent" value="class JwtAuthMiddleware&#10;  def initialize(app)&#10;    @app = app&#10;  end&#10;&#10;  def call(env)&#10;    req = Rack::Request.new(env)&#10;    auth_header = req.get_header(&quot;HTTP_AUTHORIZATION&quot;)&#10;&#10;    if auth_header.nil?&#10;      return [401, { &quot;Content-Type&quot; =&gt; &quot;application/json&quot; }, [{ error: &quot;Authorization header ausente&quot; }.to_json]]&#10;    end&#10;&#10;    if auth_header.start_with?(&quot;Basic &quot;)&#10;      # Permite passar para endpoints que usam Basic Auth (ex: /app/token)&#10;      return @app.call(env)&#10;    elsif auth_header.start_with?(&quot;Bearer &quot;)&#10;      token = auth_header.split(&quot; &quot;, 2).last&#10;      begin&#10;        secret = Rails.application.secret_key_base&#10;        decoded = JWT.decode(token, secret, false, { algorithm: &quot;HS256&quot; })&#10;        payload = decoded[0]&#10;        env[&quot;jwt.payload&quot;] = payload&#10;      rescue JWT::DecodeError =&gt; e&#10;        return [401, { &quot;Content-Type&quot; =&gt; &quot;application/json&quot; }, [{ error: &quot;Token inválido&quot;, message: e.message }.to_json]]&#10;      end&#10;      return @app.call(env)&#10;    else&#10;      return [401, { &quot;Content-Type&quot; =&gt; &quot;application/json&quot; }, [{ error: &quot;Tipo de Authorization não suportado&quot; }.to_json]]&#10;    end&#10;  end&#10;end" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/create_tb_customer_service.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/create_tb_customer_service.rb" />
              <option name="updatedContent" value="class CreateTbCustomerService&#10;  def initialize(params)&#10;    @params = params&#10;  end&#10;&#10;  def call&#10;    tb_customer = TbCustomers.new(@params)&#10;    tb_customer.createdAt = Time.now&#10;    tb_customer.updatedAt = Time.now&#10;    if tb_customer.save&#10;      { success: true, tb_customer: tb_customer }&#10;    else&#10;      { success: false, errors: tb_customer.errors }&#10;    end&#10;  end&#10;end&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/policies_service.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/policies_service.rb" />
              <option name="updatedContent" value="class PoliciesService&#10;  def self.all&#10;    TbPolicy.all&#10;  end&#10;&#10;  def self.find(id)&#10;    TbPolicy.find(id)&#10;  end&#10;&#10;  def self.create(params)&#10;    TbPolicy.create(params)&#10;  end&#10;&#10;  def self.update(policy, params)&#10;    policy.update(params)&#10;  end&#10;&#10;  def self.destroy(policy)&#10;    policy.destroy&#10;  end&#10;end&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config/application.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config/application.rb" />
              <option name="originalContent" value="require_relative &quot;boot&quot;&#10;&#10;require &quot;rails/all&quot;&#10;&#10;# Require the gems listed in Gemfile, including any gems&#10;# you've limited to :test, :development, or :production.&#10;Bundler.require(*Rails.groups)&#10;&#10;module SegDevChallenge&#10;  class Application &lt; Rails::Application&#10;    # Initialize configuration defaults for originally generated Rails version.&#10;    config.load_defaults 8.0&#10;&#10;    # Please, add to the `ignore` list any other `lib` subdirectories that do&#10;    # not contain `.rb` files, or that should not be reloaded or eager loaded.&#10;    # Common ones are `templates`, `generators`, or `middleware`, for example.&#10;    config.autoload_lib(ignore: %w[assets tasks])&#10;&#10;    config.autoload_paths &lt;&lt; Rails.root.join('app', 'middleware')&#10;    config.middleware.use JwtAuthMiddleware&#10;&#10;    # Configuration for the application, engines, and railties goes here.&#10;    #&#10;    # These settings can be overridden in specific environments using the files&#10;    # in config/environments, which are processed later.&#10;    #&#10;    # config.time_zone = &quot;Central Time (US &amp; Canada)&quot;&#10;    # config.eager_load_paths &lt;&lt; Rails.root.join(&quot;extras&quot;)&#10;  end&#10;end&#10;" />
              <option name="updatedContent" value="require_relative &quot;boot&quot;&#10;&#10;require &quot;rails/all&quot;&#10;&#10;# Require the gems listed in Gemfile, including any gems&#10;# you've limited to :test, :development, or :production.&#10;Bundler.require(*Rails.groups)&#10;&#10;module SegDevChallenge&#10;  class Application &lt; Rails::Application&#10;    # Initialize configuration defaults for originally generated Rails version.&#10;    config.load_defaults 8.0&#10;&#10;    # Please, add to the `ignore` list any other `lib` subdirectories that do&#10;    # not contain `.rb` files, or that should not be reloaded or eager loaded.&#10;    # Common ones are `templates`, `generators`, or `middleware`, for example.&#10;    config.autoload_lib(ignore: %w[assets tasks])&#10;&#10;    require_relative '../app/middleware/jwt_auth_middleware'&#10;    config.autoload_paths &lt;&lt; Rails.root.join('app', 'middleware')&#10;    config.middleware.use JwtAuthMiddleware&#10;&#10;    # Configuration for the application, engines, and railties goes here.&#10;    #&#10;    # These settings can be overridden in specific environments using the files&#10;    # in config/environments, which are processed later.&#10;    #&#10;    # config.time_zone = &quot;Central Time (US &amp; Canada)&quot;&#10;    # config.eager_load_paths &lt;&lt; Rails.root.join(&quot;extras&quot;)&#10;  end&#10;end" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config/routes.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config/routes.rb" />
              <option name="originalContent" value="Rails.application.routes.draw do&#10;&#10;  resources :tb_policies&#10;&#10;  resources :tb_customers, path: &quot;/app/v1/tb_customers&quot;&#10;&#10;  # Define your application routes per the DSL in https://guides.rubyonrails.org/routing.html&#10;&#10;  # Reveal health status on /up that returns 200 if the app boots with no exceptions, otherwise 500.&#10;  # Can be used by load balancers and uptime monitors to verify that the app is live.&#10;  get &quot;up&quot; =&gt; &quot;rails/health#show&quot;, as: :rails_health_check&#10;&#10;  # Render dynamic PWA files from app/views/pwa/* (remember to link manifest in application.html.erb)&#10;  # get &quot;manifest&quot; =&gt; &quot;rails/pwa#manifest&quot;, as: :pwa_manifest&#10;  # get &quot;service-worker&quot; =&gt; &quot;rails/pwa#service_worker&quot;, as: :pwa_service_worker&#10;&#10;  # Defines the root path route (&quot;/&quot;)&#10;  # root &quot;posts#index&quot;&#10;end&#10;" />
              <option name="updatedContent" value="Rails.application.routes.draw do&#10;&#10;  resources :tb_policies&#10;&#10;  resources :tb_customers, path: &quot;/app/v1/tb_customers&quot;&#10;&#10;  # Define your application routes per the DSL in https://guides.rubyonrails.org/routing.html&#10;&#10;  # Reveal health status on /up that returns 200 if the app boots with no exceptions, otherwise 500.&#10;  # Can be used by load balancers and uptime monitors to verify that the app is live.&#10;  get &quot;up&quot; =&gt; &quot;rails/health#show&quot;, as: :rails_health_check&#10;&#10;  # Render dynamic PWA files from app/views/pwa/* (remember to link manifest in application.html.erb)&#10;  # get &quot;manifest&quot; =&gt; &quot;rails/pwa#manifest&quot;, as: :pwa_manifest&#10;  # get &quot;service-worker&quot; =&gt; &quot;rails/pwa#service_worker&quot;, as: :pwa_service_worker&#10;&#10;  # Defines the root path route (&quot;/&quot;)&#10;  # root &quot;posts#index&quot;&#10;&#10;  post '/app/token', to: 'app#token'&#10;end" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/db/migrate/20250730180000_rename_created_at_and_updated_at_in_tb_customers.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/db/migrate/20250730180000_rename_created_at_and_updated_at_in_tb_customers.rb" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/init.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/init.sql" />
              <option name="updatedContent" value="-- Script de inicialização para o Postgres: cria a tabela tb_customers se não existir&#10;CREATE TABLE IF NOT EXISTS tb_customers (&#10;  id VARCHAR PRIMARY KEY,&#10;  username VARCHAR NOT NULL UNIQUE,&#10;  password VARCHAR NOT NULL,&#10;  role VARCHAR NOT NULL,&#10;  created_at TIMESTAMP NOT NULL,&#10;  updated_at TIMESTAMP NOT NULL&#10;);&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>