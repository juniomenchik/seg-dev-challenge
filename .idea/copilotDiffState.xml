<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/services/create_tb_customer_service.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/create_tb_customer_service.rb" />
              <option name="updatedContent" value="class CreateTbCustomerService&#10;  def initialize(params)&#10;    @params = params&#10;  end&#10;&#10;  def call&#10;    tb_customer = TbCustomers.new(@params)&#10;    tb_customer.createdAt = Time.now&#10;    tb_customer.updatedAt = Time.now&#10;    if tb_customer.save&#10;      { success: true, tb_customer: tb_customer }&#10;    else&#10;      { success: false, errors: tb_customer.errors }&#10;    end&#10;  end&#10;end&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/policies_service.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/policies_service.rb" />
              <option name="updatedContent" value="class PoliciesService&#10;  def self.all&#10;    TbPolicy.all&#10;  end&#10;&#10;  def self.find(id)&#10;    TbPolicy.find(id)&#10;  end&#10;&#10;  def self.create(params)&#10;    TbPolicy.create(params)&#10;  end&#10;&#10;  def self.update(policy, params)&#10;    policy.update(params)&#10;  end&#10;&#10;  def self.destroy(policy)&#10;    policy.destroy&#10;  end&#10;end&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/tb_policy_creator_service.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/tb_policy_creator_service.rb" />
              <option name="originalContent" value="# app/services/tb_policy_creator_service.rb&#10;class TbPolicyCreatorService&#10;  def initialize(params, payload)&#10;    @params = params&#10;    @payload = payload&#10;  end&#10;&#10;  def updateEntity&#10;    tbcustomer = TbCustomers.find_by(id: @payload[&quot;sub&quot;])&#10;&#10;    unless tbcustomer&#10;      return { success: false, errors: [&quot;Cliente não encontrado para o ID informado.&quot;] }&#10;    end&#10;&#10;    if @params[:policy_number] &amp;&amp; @params[:policy_number].to_s.length != 12&#10;      return { success: false, errors: [&quot;O policy_number deve ter exatamente 12 dígitos.&quot;] }&#10;    end&#10;&#10;    tb_policy = TbPolicy.find_by(id: @params[:id])&#10;    unless tb_policy&#10;      return { success: false, errors: [&quot;TbPolicy não encontrado para o ID informado.&quot;] }&#10;    end&#10;&#10;    &#10;    tb_policy.policy_number = @payload[&quot;policy_number&quot;]&#10;    tb_policy.policy_number = SecureRandom.random_number(10**12).to_s.rjust(12, '0')&#10;&#10;    tb_policy.tb_customer_id = @payload[&quot;tb_customer_id&quot;]&#10;    tb_policy.start_date = @params[:start_date]&#10;    tb_policy.end_date = @params[:end_date]&#10;    tb_policy.status = @params[:status]&#10;    tb_policy.updated_at = Time.now&#10;&#10;    res = tb_policy.save&#10;    unless res&#10;      puts &quot;Erros ao atualizar TbPolicy: #{tb_policy.errors.full_messages.inspect}&quot;&#10;    end&#10;&#10;    if res&#10;      puts &quot;UPDATE realizado na base para TbPolicy: #{tb_policy.inspect}&quot;&#10;      { success: true, tb_policy: tb_policy }&#10;    else&#10;      { success: false, errors: tb_policy.errors.full_messages }&#10;    end&#10;  end&#10;&#10;  def saveEntity&#10;    puts &quot;ID recebido do payload: &quot;, @payload[&quot;sub&quot;]&#10;    tbcustomer = TbCustomers.find_by(id: @payload[&quot;sub&quot;])&#10;    puts &quot;Resultado da busca do cliente: &quot;, tbcustomer.inspect&#10;&#10;    unless tbcustomer&#10;      return { success: false, errors: [&quot;Cliente não encontrado para o ID informado.&quot;] }&#10;    end&#10;&#10;    tb_policy = TbPolicy.new(@params)&#10;&#10;    tb_policy.id = SecureRandom.uuid&#10;    tb_policy.policy_number = SecureRandom.random_number(10**12).to_s.rjust(12, '0')&#10;    tb_policy.tb_customer_id = @payload[&quot;sub&quot;]&#10;    tb_policy.start_date = @params[:start_date]&#10;    tb_policy.end_date = @params[:end_date]&#10;    tb_policy.status = @params[:status]&#10;    tb_policy.created_at = Time.now&#10;    tb_policy.updated_at = Time.now&#10;&#10;    res = tb_policy.save&#10;    unless res&#10;      puts &quot;Erros ao salvar TbPolicy: #{tb_policy.errors.full_messages.inspect}&quot;&#10;    end&#10;&#10;    if res&#10;      puts &quot;INSERT realizado na base para TbPolicy: #{tb_policy.inspect}&quot;&#10;      { success: true, tb_policy: tb_policy }&#10;    else&#10;      { success: false, errors: tb_policy.errors.full_messages }&#10;    end&#10;  end&#10;end" />
              <option name="updatedContent" value="# app/services/tb_policy_creator_service.rb&#10;class TbPolicyCreatorService&#10;  def initialize(params, payload)&#10;    @params = params&#10;    @payload = payload&#10;  end&#10;&#10;  def updateEntity&#10;    tbcustomer = TbCustomers.find_by(id: @payload[&quot;sub&quot;])&#10;&#10;    unless tbcustomer&#10;      return { success: false, errors: [&quot;Cliente não encontrado para o ID informado.&quot;] }&#10;    end&#10;&#10;    if @params[:policy_number] &amp;&amp; @params[:policy_number].to_s.length != 12&#10;      return { success: false, errors: [&quot;O policy_number deve ter exatamente 12 dígitos.&quot;] }&#10;    end&#10;&#10;    tb_policy = TbPolicy.find_by(id: @params[:id])&#10;    unless tb_policy&#10;      return { success: false, errors: [&quot;TbPolicy não encontrado para o ID informado.&quot;] }&#10;    end&#10;&#10;    tb_policy.policy_number = @payload[&quot;policy_number&quot;]&#10;    tb_policy.policy_number = SecureRandom.random_number(10**12).to_s.rjust(12, '0')&#10;&#10;    tb_policy.tb_customer_id = @payload[&quot;tb_customer_id&quot;]&#10;    tb_policy.start_date = @params[:start_date]&#10;    tb_policy.end_date = @params[:end_date]&#10;    tb_policy.status = @params[:status]&#10;    tb_policy.updated_at = Time.now&#10;&#10;    res = tb_policy.save&#10;    unless res&#10;      puts &quot;Erros ao atualizar TbPolicy: #{tb_policy.errors.full_messages.inspect}&quot;&#10;    end&#10;&#10;    if res&#10;      puts &quot;UPDATE realizado na base para TbPolicy: #{tb_policy.inspect}&quot;&#10;      { success: true, tb_policy: tb_policy }&#10;    else&#10;      { success: false, errors: tb_policy.errors.full_messages }&#10;    end&#10;  end&#10;&#10;  def saveEntity&#10;    puts &quot;ID recebido do payload: &quot;, @payload[&quot;sub&quot;]&#10;    tbcustomer = TbCustomers.find_by(id: @payload[&quot;sub&quot;])&#10;    puts &quot;Resultado da busca do cliente: &quot;, tbcustomer.inspect&#10;&#10;    unless tbcustomer&#10;      return { success: false, errors: [&quot;Cliente não encontrado para o ID informado.&quot;] }&#10;    end&#10;&#10;    tb_policy = TbPolicy.new(@params)&#10;&#10;    tb_policy.id = SecureRandom.uuid&#10;    tb_policy.policy_number = SecureRandom.random_number(10**12).to_s.rjust(12, '0')&#10;    tb_policy.tb_customer_id = @payload[&quot;sub&quot;]&#10;    tb_policy.start_date = @params[:start_date]&#10;    tb_policy.end_date = @params[:end_date]&#10;    tb_policy.status = @params[:status]&#10;    tb_policy.created_at = Time.now&#10;    tb_policy.updated_at = Time.now&#10;&#10;    res = tb_policy.save&#10;    unless res&#10;      puts &quot;Erros ao salvar TbPolicy: #{tb_policy.errors.full_messages.inspect}&quot;&#10;    end&#10;&#10;    if res&#10;      puts &quot;INSERT realizado na base para TbPolicy: #{tb_policy.inspect}&quot;&#10;      { success: true, tb_policy: tb_policy }&#10;    else&#10;      { success: false, errors: tb_policy.errors.full_messages }&#10;    end&#10;  end&#10;end" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config/application.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config/application.rb" />
              <option name="originalContent" value="require_relative &quot;boot&quot;&#10;&#10;require &quot;rails/all&quot;&#10;&#10;# Require the gems listed in Gemfile, including any gems&#10;# you've limited to :test, :development, or :production.&#10;Bundler.require(*Rails.groups)&#10;&#10;module SegDevChallenge&#10;  class Application &lt; Rails::Application&#10;    # Initialize configuration defaults for originally generated Rails version.&#10;    config.load_defaults 8.0&#10;&#10;    # Please, add to the `ignore` list any other `lib` subdirectories that do&#10;    # not contain `.rb` files, or that should not be reloaded or eager loaded.&#10;    # Common ones are `templates`, `generators`, or `middleware`, for example.&#10;    config.autoload_lib(ignore: %w[assets tasks])&#10;&#10;    config.autoload_paths &lt;&lt; Rails.root.join('app', 'middleware')&#10;    config.middleware.use JwtAuthMiddleware&#10;&#10;    # Configuration for the application, engines, and railties goes here.&#10;    #&#10;    # These settings can be overridden in specific environments using the files&#10;    # in config/environments, which are processed later.&#10;    #&#10;    # config.time_zone = &quot;Central Time (US &amp; Canada)&quot;&#10;    # config.eager_load_paths &lt;&lt; Rails.root.join(&quot;extras&quot;)&#10;  end&#10;end&#10;" />
              <option name="updatedContent" value="require_relative &quot;boot&quot;&#10;&#10;require &quot;rails/all&quot;&#10;&#10;# Require the gems listed in Gemfile, including any gems&#10;# you've limited to :test, :development, or :production.&#10;Bundler.require(*Rails.groups)&#10;&#10;module SegDevChallenge&#10;  class Application &lt; Rails::Application&#10;    # Initialize configuration defaults for originally generated Rails version.&#10;    config.load_defaults 8.0&#10;&#10;    # Please, add to the `ignore` list any other `lib` subdirectories that do&#10;    # not contain `.rb` files, or that should not be reloaded or eager loaded.&#10;    # Common ones are `templates`, `generators`, or `middleware`, for example.&#10;    config.autoload_lib(ignore: %w[assets tasks])&#10;&#10;    require_relative '../app/middleware/jwt_auth_middleware'&#10;    config.autoload_paths &lt;&lt; Rails.root.join('app', 'middleware')&#10;    config.middleware.use JwtAuthMiddleware&#10;&#10;    # Configuration for the application, engines, and railties goes here.&#10;    #&#10;    # These settings can be overridden in specific environments using the files&#10;    # in config/environments, which are processed later.&#10;    #&#10;    # config.time_zone = &quot;Central Time (US &amp; Canada)&quot;&#10;    # config.eager_load_paths &lt;&lt; Rails.root.join(&quot;extras&quot;)&#10;  end&#10;end" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config/environments/development.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config/environments/development.rb" />
              <option name="originalContent" value="require &quot;active_support/core_ext/integer/time&quot;&#10;&#10;Rails.application.configure do&#10;  # Settings specified here will take precedence over those in config/application.rb.&#10;&#10;  # Make code changes take effect immediately without server restart.&#10;  config.enable_reloading = true&#10;&#10;  # Do not eager load code on boot.&#10;  config.eager_load = false&#10;&#10;  # Show full error reports.&#10;  config.consider_all_requests_local = true&#10;&#10;  # Enable server timing.&#10;  config.server_timing = true&#10;&#10;  # Enable/disable Action Controller caching. By default Action Controller caching is disabled.&#10;  # Run rails dev:cache to toggle Action Controller caching.&#10;  if Rails.root.join(&quot;tmp/caching-dev.txt&quot;).exist?&#10;    config.action_controller.perform_caching = true&#10;    config.action_controller.enable_fragment_cache_logging = true&#10;    config.public_file_server.headers = { &quot;cache-control&quot; =&gt; &quot;public, max-age=#{2.days.to_i}&quot; }&#10;  else&#10;    config.action_controller.perform_caching = false&#10;  end&#10;&#10;  # Change to :null_store to avoid any caching.&#10;  config.cache_store = :memory_store&#10;&#10;  # Store uploaded files on the local file system (see config/storage.yml for options).&#10;  config.active_storage.service = :local&#10;&#10;  # Don't care if the mailer can't send.&#10;  config.action_mailer.raise_delivery_errors = false&#10;&#10;  # Make template changes take effect immediately.&#10;  config.action_mailer.perform_caching = false&#10;&#10;  # Set localhost to be used by links generated in mailer templates.&#10;  config.action_mailer.default_url_options = { host: &quot;localhost&quot;, port: 3000 }&#10;&#10;  # Print deprecation notices to the Rails logger.&#10;  config.active_support.deprecation = :log&#10;&#10;  # Raise an error on page load if there are pending migrations.&#10;  config.active_record.migration_error = :page_load&#10;&#10;  # Highlight code that triggered database queries in logs.&#10;  config.active_record.verbose_query_logs = true&#10;&#10;  # Append comments with runtime information tags to SQL queries in logs.&#10;  config.active_record.query_log_tags_enabled = true&#10;&#10;  # Highlight code that enqueued background job in logs.&#10;  config.active_job.verbose_enqueue_logs = true&#10;&#10;  # Raises error for missing translations.&#10;  # config.i18n.raise_on_missing_translations = true&#10;&#10;  # Annotate rendered view with file names.&#10;  config.action_view.annotate_rendered_view_with_filenames = true&#10;&#10;  # Uncomment if you wish to allow Action Cable access from any origin.&#10;  # config.action_cable.disable_request_forgery_protection = true&#10;&#10;  # Raise error when a before_action's only/except options reference missing actions.&#10;  config.action_controller.raise_on_missing_callback_actions = true&#10;&#10;  # Apply autocorrection by RuboCop to files generated by `bin/rails generate`.&#10;  # config.generators.apply_rubocop_autocorrect_after_generate!&#10;end&#10;" />
              <option name="updatedContent" value="require &quot;active_support/core_ext/integer/time&quot;&#10;&#10;Rails.application.configure do&#10;  # Settings specified here will take precedence over those in config/application.rb.&#10;&#10;  # Make code changes take effect immediately without server restart.&#10;  config.enable_reloading = true&#10;&#10;  # Do not eager load code on boot.&#10;  config.eager_load = false&#10;&#10;  # Show full error reports.&#10;  config.consider_all_requests_local = true&#10;&#10;  # Enable server timing.&#10;  config.server_timing = true&#10;&#10;  # Enable/disable Action Controller caching. By default Action Controller caching is disabled.&#10;  # Run rails dev:cache to toggle Action Controller caching.&#10;  if Rails.root.join(&quot;tmp/caching-dev.txt&quot;).exist?&#10;    config.action_controller.perform_caching = true&#10;    config.action_controller.enable_fragment_cache_logging = true&#10;    config.public_file_server.headers = { &quot;cache-control&quot; =&gt; &quot;public, max-age=#{2.days.to_i}&quot; }&#10;  else&#10;    config.action_controller.perform_caching = false&#10;  end&#10;&#10;  # Change to :null_store to avoid any caching.&#10;  config.cache_store = :memory_store&#10;&#10;  # Store uploaded files on the local file system (see config/storage.yml for options).&#10;  config.active_storage.service = :local&#10;&#10;  # Don't care if the mailer can't send.&#10;  config.action_mailer.raise_delivery_errors = false&#10;&#10;  # Make template changes take effect immediately.&#10;  config.action_mailer.perform_caching = false&#10;&#10;  # Set localhost to be used by links generated in mailer templates.&#10;  config.action_mailer.default_url_options = { host: &quot;localhost&quot;, port: 3000 }&#10;&#10;  # Print deprecation notices to the Rails logger.&#10;  config.active_support.deprecation = :log&#10;&#10;  # Raise an error on page load if there are pending migrations.&#10;  config.active_record.migration_error = :page_load&#10;&#10;  # Highlight code that triggered database queries in logs.&#10;  config.active_record.verbose_query_logs = true&#10;&#10;  # Append comments with runtime information tags to SQL queries in logs.&#10;  config.active_record.query_log_tags_enabled = true&#10;&#10;  # Highlight code that enqueued background job in logs.&#10;  config.active_job.verbose_enqueue_logs = true&#10;&#10;  # Raises error for missing translations.&#10;  # config.i18n.raise_on_missing_translations = true&#10;&#10;  # Annotate rendered view with file names.&#10;  config.action_view.annotate_rendered_view_with_filenames = true&#10;&#10;  # Uncomment if you wish to allow Action Cable access from any origin.&#10;  # config.action_cable.disable_request_forgery_protection = true&#10;&#10;  # Raise error when a before_action's only/except options reference missing actions.&#10;  config.action_controller.raise_on_missing_callback_actions = true&#10;&#10;  # Apply autocorrection by RuboCop to files generated by `bin/rails generate`.&#10;  # config.generators.apply_rubocop_autocorrect_after_generate!&#10;&#10;  Rails.logger = Logger.new(STDOUT)&#10;  ActiveRecord::Base.logger = Rails.logger&#10;end" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/db/migrate/20250730180000_rename_created_at_and_updated_at_in_tb_customers.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/db/migrate/20250730180000_rename_created_at_and_updated_at_in_tb_customers.rb" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>