<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/controllers/application_controller.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/controllers/application_controller.rb" />
              <option name="originalContent" value="class ApplicationController &lt; ActionController::Base&#10;  # Only allow modern browsers supporting webp images, web push, badges, import maps, CSS nesting, and CSS :has.&#10;  allow_browser versions: :modern&#10;&#10;  # Desabilitar verificação de migrações pendentes já que usamos script SQL customizado&#10;  self.check_pending_migrations = false&#10;&#10;  # Desabilitar verificação de migrações pendentes já que usamos script SQL customizado&#10;  self.check_pending_migrations = false&#10;end&#10;" />
              <option name="updatedContent" value="class ApplicationController &lt; ActionController::Base&#10;  # Only allow modern browsers supporting webp images, web push, badges, import maps, CSS nesting, and CSS :has.&#10;  allow_browser versions: :modern&#10;end" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/create_tb_customer_service.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/create_tb_customer_service.rb" />
              <option name="updatedContent" value="class CreateTbCustomerService&#10;  def initialize(params)&#10;    @params = params&#10;  end&#10;&#10;  def call&#10;    tb_customer = TbCustomers.new(@params)&#10;    tb_customer.createdAt = Time.now&#10;    tb_customer.updatedAt = Time.now&#10;    if tb_customer.save&#10;      { success: true, tb_customer: tb_customer }&#10;    else&#10;      { success: false, errors: tb_customer.errors }&#10;    end&#10;  end&#10;end&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/policies_service.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/policies_service.rb" />
              <option name="updatedContent" value="class PoliciesService&#10;  def self.all&#10;    TbPolicy.all&#10;  end&#10;&#10;  def self.find(id)&#10;    TbPolicy.find(id)&#10;  end&#10;&#10;  def self.create(params)&#10;    TbPolicy.create(params)&#10;  end&#10;&#10;  def self.update(policy, params)&#10;    policy.update(params)&#10;  end&#10;&#10;  def self.destroy(policy)&#10;    policy.destroy&#10;  end&#10;end&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config/initializers/splunk_logger.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config/initializers/splunk_logger.rb" />
              <option name="originalContent" value="# frozen_string_literal: true&#10;&#10;require 'net/http'&#10;require 'json'&#10;require 'uri'&#10;&#10;# Classe helper para logging estruturado com envio para Splunk&#10;class AppLogger&#10;  def self.splunk_enabled?&#10;    ENV['SPLUNK_TOKEN'].present? &amp;&amp; ENV['SPLUNK_TOKEN'] != 'your-hec-token'&#10;  end&#10;&#10;  def self.send_to_splunk(log_data)&#10;    return unless splunk_enabled?&#10;&#10;    begin&#10;      splunk_host = ENV.fetch('SPLUNK_HOST', 'splunk')&#10;      splunk_port = ENV.fetch('SPLUNK_PORT', '8088')&#10;      splunk_token = ENV.fetch('SPLUNK_TOKEN', '32bb54a7-646a-4d3e-bf65-3cbbd9075a56')&#10;&#10;      uri = URI(&quot;https://#{splunk_host}:#{splunk_port}/services/collector/event&quot;)  # Manter https como no curl&#10;&#10;      http = Net::HTTP.new(uri.host, uri.port)&#10;      http.use_ssl = true  # Mudança para true para usar HTTPS como no curl&#10;      http.verify_mode = OpenSSL::SSL::VERIFY_NONE  # Pular verificação SSL para localhost&#10;      http.read_timeout = 10&#10;      http.open_timeout = 10&#10;&#10;      request = Net::HTTP::Post.new(uri)&#10;      request['Authorization'] = &quot;Splunk #{splunk_token}&quot;&#10;      request['Content-Type'] = 'application/json'&#10;&#10;      # Estrutura de envio conforme especificado - log_data direto no event&#10;      splunk_payload = {&#10;        event: log_data,  # Enviar o objeto completo como no formato que funciona&#10;        index: &quot;main&quot;&#10;      }&#10;&#10;      request.body = splunk_payload.to_json&#10;&#10;      # Log do curl equivalente para debug&#10;      curl_command = &quot;curl --location '#{uri}' \\\n&quot;&#10;      curl_command += &quot;--header 'Authorization: #{request['Authorization']}' \\\n&quot;&#10;      curl_command += &quot;--header 'Content-Type: #{request['Content-Type']}' \\\n&quot;&#10;      curl_command += &quot;--data '#{request.body}'&quot;&#10;&#10;      Rails.logger.debug &quot;Curl equivalente:\n#{curl_command}&quot;&#10;&#10;      response = http.request(request)&#10;&#10;      unless response.code.to_i == 200&#10;        Rails.logger.warn &quot;Falha ao enviar para Splunk: #{response.code} - #{response.body}&quot;&#10;      else&#10;&#10;        if response.code.to_i == 400&#10;          puts &quot;Invalid data formator caralho&quot;&#10;        end&#10;&#10;        Rails.logger.debug &quot;Log enviado com sucesso para Splunk HEC&quot;&#10;      end&#10;    rescue =&gt; e&#10;&#10;      if e.code.to_i == 400&#10;        puts &quot;Invalid data formator caralho&quot;&#10;      end&#10;&#10;      Rails.logger.warn &quot;Erro ao enviar para Splunk: #{e.message}&quot;&#10;    end&#10;  end&#10;&#10;  def self.info(message, data = {})&#10;    log_data = {&#10;      level: &quot;INFO&quot;,&#10;      message: message,&#10;      timestamp: Time.current.utc.iso8601,&#10;      application: &quot;seg-dev-challenge&quot;,&#10;      environment: Rails.env&#10;    }.merge(data)&#10;&#10;    Rails.logger.info(log_data.to_json)&#10;    send_to_splunk(log_data)&#10;  end&#10;&#10;  def self.error(message, data = {})&#10;    log_data = {&#10;      level: &quot;ERROR&quot;,&#10;      message: message,&#10;      timestamp: Time.current.utc.iso8601,&#10;      application: &quot;seg-dev-challenge&quot;,&#10;      environment: Rails.env&#10;    }.merge(data)&#10;&#10;    Rails.logger.error(log_data.to_json)&#10;    send_to_splunk(log_data)&#10;  end&#10;&#10;  def self.warn(message, data = {})&#10;    log_data = {&#10;      level: &quot;WARN&quot;,&#10;      message: message,&#10;      timestamp: Time.current.utc.iso8601,&#10;      application: &quot;seg-dev-challenge&quot;,&#10;      environment: Rails.env&#10;    }.merge(data)&#10;&#10;    Rails.logger.warn(log_data.to_json)&#10;    send_to_splunk(log_data)&#10;  end&#10;&#10;  def self.debug(message, data = {})&#10;    log_data = {&#10;      level: &quot;DEBUG&quot;,&#10;      message: message,&#10;      timestamp: Time.current.utc.iso8601,&#10;      application: &quot;seg-dev-challenge&quot;,&#10;      environment: Rails.env&#10;    }.merge(data)&#10;&#10;    Rails.logger.debug(log_data.to_json)&#10;    send_to_splunk(log_data)&#10;  end&#10;end&#10;" />
              <option name="updatedContent" value="# frozen_string_literal: true&#10;&#10;require 'net/http'&#10;require 'json'&#10;require 'uri'&#10;&#10;# Classe helper para logging estruturado com envio para Splunk&#10;class AppLogger&#10;  def self.splunk_enabled?&#10;    ENV['SPLUNK_TOKEN'].present? &amp;&amp; ENV['SPLUNK_TOKEN'] != 'your-hec-token'&#10;  end&#10;&#10;  def self.send_to_splunk(log_data)&#10;    return unless splunk_enabled?&#10;&#10;    begin&#10;      splunk_host = ENV.fetch('SPLUNK_HOST', 'splunk')&#10;      splunk_port = ENV.fetch('SPLUNK_PORT', '8088')&#10;      splunk_token = ENV.fetch('SPLUNK_TOKEN', '32bb54a7-646a-4d3e-bf65-3cbbd9075a56')&#10;&#10;      uri = URI(&quot;https://#{splunk_host}:#{splunk_port}/services/collector/event&quot;)  # Manter https como no curl&#10;&#10;      http = Net::HTTP.new(uri.host, uri.port)&#10;      http.use_ssl = true  # Mudança para true para usar HTTPS como no curl&#10;      http.verify_mode = OpenSSL::SSL::VERIFY_NONE  # Pular verificação SSL para localhost&#10;      http.read_timeout = 10&#10;      http.open_timeout = 10&#10;&#10;      request = Net::HTTP::Post.new(uri)&#10;      request['Authorization'] = &quot;Splunk #{splunk_token}&quot;&#10;      request['Content-Type'] = 'application/json'&#10;&#10;      # Estrutura igual ao curl que funciona&#10;      splunk_payload = {&#10;        event: log_data,  # Enviar o objeto completo como no formato que funciona&#10;        index: &quot;main&quot;&#10;      }&#10;&#10;      request.body = splunk_payload.to_json&#10;&#10;      # Log do curl equivalente para debug&#10;      curl_command = &quot;curl --location '#{uri}' \\\n&quot;&#10;      curl_command += &quot;--header 'Authorization: #{request['Authorization']}' \\\n&quot;&#10;      curl_command += &quot;--header 'Content-Type: #{request['Content-Type']}' \\\n&quot;&#10;      curl_command += &quot;--data '#{request.body}'&quot;&#10;&#10;      Rails.logger.debug &quot;Curl equivalente:\n#{curl_command}&quot;&#10;&#10;      response = http.request(request)&#10;&#10;      unless response.code.to_i == 200&#10;        Rails.logger.warn &quot;Falha ao enviar para Splunk: #{response.code} - #{response.body}&quot;&#10;      else&#10;&#10;        if response.code.to_i == 400&#10;          puts &quot;Invalid data formator caralho&quot;&#10;        end&#10;&#10;        Rails.logger.debug &quot;Log enviado com sucesso para Splunk HEC&quot;&#10;      end&#10;    rescue =&gt; e&#10;&#10;      if e.code.to_i == 400&#10;        puts &quot;Invalid data formator caralho&quot;&#10;      end&#10;&#10;      Rails.logger.warn &quot;Erro ao enviar para Splunk: #{e.message}&quot;&#10;    end&#10;  end&#10;&#10;  def self.info(message, data = {})&#10;    log_data = {&#10;      level: &quot;INFO&quot;,&#10;      message: message,&#10;      timestamp: Time.current.utc.iso8601,&#10;      application: &quot;seg-dev-challenge&quot;,&#10;      environment: Rails.env&#10;    }.merge(data)&#10;&#10;    Rails.logger.info(log_data.to_json)&#10;    send_to_splunk(log_data)&#10;  end&#10;&#10;  def self.error(message, data = {})&#10;    log_data = {&#10;      level: &quot;ERROR&quot;,&#10;      message: message,&#10;      timestamp: Time.current.utc.iso8601,&#10;      application: &quot;seg-dev-challenge&quot;,&#10;      environment: Rails.env&#10;    }.merge(data)&#10;&#10;    Rails.logger.error(log_data.to_json)&#10;    send_to_splunk(log_data)&#10;  end&#10;&#10;  def self.warn(message, data = {})&#10;    log_data = {&#10;      level: &quot;WARN&quot;,&#10;      message: message,&#10;      timestamp: Time.current.utc.iso8601,&#10;      application: &quot;seg-dev-challenge&quot;,&#10;      environment: Rails.env&#10;    }.merge(data)&#10;&#10;    Rails.logger.warn(log_data.to_json)&#10;    send_to_splunk(log_data)&#10;  end&#10;&#10;  def self.debug(message, data = {})&#10;    log_data = {&#10;      level: &quot;DEBUG&quot;,&#10;      message: message,&#10;      timestamp: Time.current.utc.iso8601,&#10;      application: &quot;seg-dev-challenge&quot;,&#10;      environment: Rails.env&#10;    }.merge(data)&#10;&#10;    Rails.logger.debug(log_data.to_json)&#10;    send_to_splunk(log_data)&#10;  end&#10;end" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/configure-splunk-hec.bat">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/configure-splunk-hec.bat" />
              <option name="updatedContent" value="@echo off&#10;echo Aguardando Splunk estar disponivel...&#10;&#10;set timeout=300&#10;set counter=0&#10;&#10;:wait_loop&#10;curl -s -u admin:SenhaForte123 &quot;http://localhost:8089/services/server/info&quot; &gt;nul 2&gt;&amp;1&#10;if %errorlevel% equ 0 (&#10;    echo Splunk esta pronto!&#10;    goto configure&#10;)&#10;&#10;echo Aguardando Splunk... (%counter%/%timeout% segundos)&#10;timeout /t 10 /nobreak &gt;nul&#10;set /a counter+=10&#10;&#10;if %counter% geq %timeout% (&#10;    echo Timeout aguardando Splunk iniciar&#10;    exit /b 1&#10;)&#10;&#10;goto wait_loop&#10;&#10;:configure&#10;echo Configurando HEC...&#10;&#10;echo Criando indice rails_app...&#10;docker exec splunk /opt/splunk/bin/splunk add index rails_app -auth admin:SenhaForte123 2&gt;nul || echo Indice rails_app ja existe&#10;&#10;echo Criando HEC token...&#10;docker exec splunk /opt/splunk/bin/splunk http-event-collector create -name &quot;rails_app&quot; -index rails_app -description &quot;Token para aplicacao Rails&quot; -source &quot;middleware&quot; -sourcetype &quot;_json&quot; -token &quot;32bb54a7-646a-4d3e-bf65-3cbbd9075a56&quot; -uri http://localhost:8089 -auth admin:SenhaForte123 2&gt;nul || echo HEC token ja existe&#10;&#10;echo Habilitando HEC...&#10;docker exec splunk /opt/splunk/bin/splunk http-event-collector enable -uri http://localhost:8089 -auth admin:SenhaForte123&#10;&#10;echo HEC configurado com sucesso!&#10;echo Splunk esta disponivel em: http://localhost:8000&#10;echo Usuario: admin&#10;echo Senha: SenhaForte123&#10;echo HEC Token: 32bb54a7-646a-4d3e-bf65-3cbbd9075a56&#10;&#10;pause" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/configure-splunk-hec.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/configure-splunk-hec.sh" />
              <option name="updatedContent" value="#!/bin/bash&#10;&#10;echo &quot;Aguardando Splunk estar disponível...&quot;&#10;&#10;# Aguarda o Splunk estar pronto&#10;timeout=300&#10;counter=0&#10;while [ $counter -lt $timeout ]; do&#10;    if curl -s -u admin:SenhaForte123 &quot;http://localhost:8089/services/server/info&quot; &gt; /dev/null 2&gt;&amp;1; then&#10;        echo &quot;Splunk está pronto!&quot;&#10;        break&#10;    fi&#10;    echo &quot;Aguardando Splunk... ($counter/$timeout segundos)&quot;&#10;    sleep 10&#10;    counter=$((counter + 10))&#10;done&#10;&#10;if [ $counter -ge $timeout ]; then&#10;    echo &quot;Timeout aguardando Splunk iniciar&quot;&#10;    exit 1&#10;fi&#10;&#10;echo &quot;Configurando HEC...&quot;&#10;&#10;# Cria o índice rails_app&#10;docker exec splunk /opt/splunk/bin/splunk add index rails_app -auth admin:SenhaForte123 2&gt;/dev/null || echo &quot;Índice rails_app já existe&quot;&#10;&#10;# Cria o HEC token&#10;docker exec splunk /opt/splunk/bin/splunk http-event-collector create \&#10;  -name &quot;rails_app&quot; \&#10;  -index rails_app \&#10;  -description &quot;Token para aplicação Rails&quot; \&#10;  -source &quot;middleware&quot; \&#10;  -sourcetype &quot;_json&quot; \&#10;  -token &quot;32bb54a7-646a-4d3e-bf65-3cbbd9075a56&quot; \&#10;  -uri http://localhost:8089 \&#10;  -auth admin:SenhaForte123 2&gt;/dev/null || echo &quot;HEC token já existe&quot;&#10;&#10;# Habilita o HEC&#10;docker exec splunk /opt/splunk/bin/splunk http-event-collector enable -uri http://localhost:8089 -auth admin:SenhaForte123&#10;&#10;echo &quot;HEC configurado com sucesso!&quot;&#10;echo &quot;Splunk está disponível em: http://localhost:8000&quot;&#10;echo &quot;Usuário: admin&quot;&#10;echo &quot;Senha: SenhaForte123&quot;&#10;echo &quot;HEC Token: 32bb54a7-646a-4d3e-bf65-3cbbd9075a56&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/db/migrate/20250730180000_rename_created_at_and_updated_at_in_tb_customers.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/db/migrate/20250730180000_rename_created_at_and_updated_at_in_tb_customers.rb" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/splunk/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/splunk/Dockerfile" />
              <option name="originalContent" value="FROM splunk/splunk:latest&#10;&#10;USER root&#10;&#10;COPY splunk/init.sh /opt/splunk/bin/init.sh&#10;RUN chmod +x /opt/splunk/bin/init.sh&#10;&#10;USER splunk&#10;&#10;CMD [&quot;/opt/splunk/bin/init.sh&quot;]&#10;&#10;&#10;" />
              <option name="updatedContent" value="FROM splunk/splunk:latest&#10;&#10;# Apenas copia o script de configuração&#10;COPY splunk/init.sh /opt/splunk/bin/configure-hec.sh&#10;RUN chmod +x /opt/splunk/bin/configure-hec.sh&#10;&#10;# Usa o entrypoint padrão do Splunk&#10;# O script de configuração será executado após o Splunk iniciar" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>