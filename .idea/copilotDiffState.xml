<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Dockerfile" />
              <option name="originalContent" value="# Use the official Ruby image as the base image&#10;FROM ruby:3.2.1&#10;&#10;# Set environment variables to avoid installing documentation for gems&#10;ENV BUNDLE_PATH=/gems \&#10;    BUNDLE_JOBS=4 \&#10;    BUNDLE_RETRY=3 \&#10;    BUNDLE_APP_CONFIG=/gems/config&#10;&#10;# Set the working directory inside the container&#10;WORKDIR /app&#10;&#10;# Copy the Gemfile and Gemfile.lock into the container&#10;COPY Gemfile Gemfile.lock ./&#10;&#10;# Install dependencies&#10;RUN bundle install&#10;&#10;# Copy the rest of the application code into the container&#10;COPY . .&#10;&#10;# Expose the port your app runs on (e.g., 3000 for Rails apps)&#10;EXPOSE 3000&#10;&#10;# Define the command to run your application&#10;CMD [&quot;ruby&quot;, &quot;app.rb&quot;]&#10;# Replace with your app's entry point, e.g., `rails server` for Rails apps" />
              <option name="updatedContent" value="# Use the official Ruby image as the base image&#10;FROM ruby:3.2.1&#10;&#10;# Install system dependencies&#10;RUN apt-get update -qq &amp;&amp; \&#10;    apt-get install -y build-essential libpq-dev nodejs &amp;&amp; \&#10;    rm -rf /var/lib/apt/lists/*&#10;&#10;# Set environment variables&#10;ENV RAILS_ENV=development \&#10;    BUNDLE_PATH=/gems \&#10;    BUNDLE_JOBS=4 \&#10;    BUNDLE_RETRY=3&#10;&#10;# Set the working directory inside the container&#10;WORKDIR /app&#10;&#10;# Copy the Gemfile and Gemfile.lock into the container&#10;COPY Gemfile Gemfile.lock ./&#10;&#10;# Install dependencies&#10;RUN bundle install&#10;&#10;# Copy the rest of the application code into the container&#10;COPY . .&#10;&#10;# Create necessary directories&#10;RUN mkdir -p tmp/pids&#10;&#10;# Expose the port your app runs on&#10;EXPOSE 3000&#10;&#10;# Define the command to run your Rails application&#10;CMD [&quot;bundle&quot;, &quot;exec&quot;, &quot;rails&quot;, &quot;server&quot;, &quot;-b&quot;, &quot;0.0.0.0&quot;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/controllers/application_controller.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/controllers/application_controller.rb" />
              <option name="originalContent" value="class ApplicationController &lt; ActionController::Base&#10;  # Only allow modern browsers supporting webp images, web push, badges, import maps, CSS nesting, and CSS :has.&#10;  allow_browser versions: :modern&#10;&#10;  # Desabilitar verificação de migrações pendentes já que usamos script SQL customizado&#10;  self.check_pending_migrations = false&#10;end&#10;" />
              <option name="updatedContent" value="class ApplicationController &lt; ActionController::Base&#10;  # Only allow modern browsers supporting webp images, web push, badges, import maps, CSS nesting, and CSS :has.&#10;  allow_browser versions: :modern&#10;end" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/controllers/tb_customers_controller.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/controllers/tb_customers_controller.rb" />
              <option name="originalContent" value="class TbCustomersController &lt; ApplicationController&#10;&#10;  before_action :require_admin_scope&#10;  skip_before_action :verify_authenticity_token&#10;&#10;  before_action do&#10;    @user_cpf = request.env[&quot;jwt.payload&quot;] &amp;&amp; request.env[&quot;jwt.payload&quot;][&quot;sub&quot;]&#10;  end&#10;&#10;  def require_admin_scope&#10;    @token_service = TbTokenService.new(request)&#10;    unless @token_service.has_scope?([&quot;ADMIN_SCOPE&quot;])&#10;      render json: { error: &quot;Escopo insuficiente&quot; }, status: :forbidden&#10;    end&#10;  end&#10;&#10;  # GET /tb_customers&#10;  def index&#10;    @tb_customers = TbCustomers.all&#10;    render json: @tb_customers&#10;  end&#10;&#10;  # GET /tb_customers/1&#10;  def show&#10;    @tb_customers = TbCustomers.find_by(id: params[:id])&#10;    render json: @tb_customers&#10;  end&#10;&#10;  # POST /tb_customers&#10;  def create&#10;    service = TbCustomerService.new(tb_customer_params.merge(id: params[:id]))&#10;&#10;    result = service.create&#10;    if result[:success]&#10;      render json: result[:tb_customer], status: :created&#10;    else&#10;      render json: result[:errors], status: :unprocessable_entity&#10;    end&#10;  end&#10;&#10;  # PATCH/PUT /tb_customers/1&#10;  def update&#10;    service = TbCustomerService.new(tb_customer_params.merge(id: params[:id]))&#10;&#10;    result = service.update&#10;    if result[:success]&#10;      render json: result[:tb_customer], status: :ok&#10;    else&#10;      render json: result[:errors], status: :unprocessable_entity&#10;    end&#10;  end&#10;&#10;  # DELETE /tb_customers/1&#10;  def destroy&#10;    service = TbCustomerService.new(id: params[:id])&#10;&#10;    result = service.deleteById&#10;    if result[:success]&#10;      head :no_content&#10;    else&#10;      render json: result[:errors], status: :unprocessable_entity&#10;    end&#10;  end&#10;&#10;  private&#10;    # Use callbacks to share common setup or constraints between actions.&#10;    def set_tb_customer&#10;      @tb_customer = TbCustomers.find(params[:id])&#10;    end&#10;&#10;    # Only allow a list of trusted parameters through.&#10;    def tb_customer_params&#10;      params.require(:tb_customer).permit(:username, :password, :role)&#10;    end&#10;end&#10;" />
              <option name="updatedContent" value="class TbCustomersController &lt; ApplicationController&#10;&#10;  before_action :require_admin_scope&#10;  skip_before_action :verify_authenticity_token&#10;&#10;  before_action do&#10;    @user_cpf = request.env[&quot;jwt.payload&quot;] &amp;&amp; request.env[&quot;jwt.payload&quot;][&quot;sub&quot;]&#10;  end&#10;&#10;  def require_admin_scope&#10;    @token_service = TbTokenService.new(request)&#10;    &#10;    # Verificar primeiro se o token está expirado&#10;    if @token_service.token_expired?&#10;      render json: { error: &quot;Token expirado&quot; }, status: :unauthorized&#10;      return&#10;    end&#10;    &#10;    unless @token_service.has_scope?([&quot;ADMIN_SCOPE&quot;])&#10;      render json: { error: &quot;Escopo insuficiente&quot; }, status: :forbidden&#10;    end&#10;  end&#10;&#10;  # GET /tb_customers&#10;  def index&#10;    @tb_customers = TbCustomers.all&#10;    render json: @tb_customers&#10;  end&#10;&#10;  # GET /tb_customers/1&#10;  def show&#10;    @tb_customers = TbCustomers.find_by(id: params[:id])&#10;    render json: @tb_customers&#10;  end&#10;&#10;  # POST /tb_customers&#10;  def create&#10;    service = TbCustomerService.new(tb_customer_params.merge(id: params[:id]))&#10;&#10;    result = service.create&#10;    if result[:success]&#10;      render json: result[:tb_customer], status: :created&#10;    else&#10;      render json: result[:errors], status: :unprocessable_entity&#10;    end&#10;  end&#10;&#10;  # PATCH/PUT /tb_customers/1&#10;  def update&#10;    service = TbCustomerService.new(tb_customer_params.merge(id: params[:id]))&#10;&#10;    result = service.update&#10;    if result[:success]&#10;      render json: result[:tb_customer], status: :ok&#10;    else&#10;      render json: result[:errors], status: :unprocessable_entity&#10;    end&#10;  end&#10;&#10;  # DELETE /tb_customers/1&#10;  def destroy&#10;    service = TbCustomerService.new(id: params[:id])&#10;&#10;    result = service.deleteById&#10;    if result[:success]&#10;      head :no_content&#10;    else&#10;      render json: result[:errors], status: :unprocessable_entity&#10;    end&#10;  end&#10;&#10;  private&#10;    # Use callbacks to share common setup or constraints between actions.&#10;    def set_tb_customer&#10;      @tb_customer = TbCustomers.find(params[:id])&#10;    end&#10;&#10;    # Only allow a list of trusted parameters through.&#10;    def tb_customer_params&#10;      params.require(:tb_customer).permit(:username, :password, :role)&#10;    end&#10;end" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/controllers/tb_policies_controller.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/controllers/tb_policies_controller.rb" />
              <option name="originalContent" value="class TbPoliciesController &lt; ApplicationController&#10;&#10;  def tb_policy_params&#10;    params.require(:tb_policy).permit(:id, :policy_number, :tb_customer_id, :start_date, :end_date, :status, :created_at, :updated_at)&#10;  end&#10;&#10;  skip_before_action :verify_authenticity_token&#10;&#10;  before_action do&#10;    @token_service = TbTokenService.new(request)&#10;    @user_cpf = request.env[&quot;jwt.payload&quot;] &amp;&amp; request.env[&quot;jwt.payload&quot;][&quot;sub&quot;]&#10;&#10;    # Verificar se o token está expirado&#10;    if @token_service.token_expired?&#10;      render json: { error: &quot;Token expirado&quot; }, status: :unauthorized&#10;      return&#10;    end&#10;  end&#10;&#10;  before_action only: [:update, :destroy] do&#10;    unless @token_service.has_scope?([&quot;ADMIN_SCOPE&quot;])&#10;      render json: { error: &quot;Escopo insuficiente&quot; }, status: :forbidden&#10;      next&#10;    end&#10;  end&#10;&#10;  before_action only: [:create] do&#10;    unless @token_service.has_scope?(%w[ADMIN_SCOPE OPERATOR_SCOPE])&#10;      render json: { error: &quot;Escopo insuficiente&quot; }, status: :forbidden&#10;      next&#10;    end&#10;  end&#10;&#10;  def index&#10;    service = TbPolicyCreatorService.new({}, request.env[&quot;jwt.payload&quot;])&#10;&#10;    if @token_service.has_scope?([&quot;ADMIN_SCOPE&quot;, &quot;OPERATOR_SCOPE&quot;])&#10;      result = service.findAll&#10;    else&#10;      result = service.findAllById(@user_cpf)&#10;    end&#10;&#10;    if result[:success]&#10;      render json: result[:tb_policies], status: :ok&#10;    else&#10;      render json: { errors: result[:errors] }, status: :not_found&#10;    end&#10;  end&#10;&#10;# GET /tb_policies/1&#10;  def show&#10;    service = TbPolicyCreatorService.new({}, request.env[&quot;jwt.payload&quot;])&#10;&#10;    result = service.findById(params[:id])&#10;&#10;    if result[:success]&#10;      render json: result[:tb_policy], status: :ok&#10;    else&#10;      render json: { errors: result[:errors] }, status: :not_found&#10;    end&#10;  end&#10;&#10;  # POST /tb_policies&#10;  def create&#10;    service = TbPolicyCreatorService.new(tb_policy_params, request.env[&quot;jwt.payload&quot;])&#10;&#10;    result = service.saveEntity&#10;&#10;    if result[:success]&#10;      render json: result[:tb_policy], status: :created&#10;    else&#10;      render json: { errors: result[:errors] }, status: :unprocessable_entity&#10;    end&#10;  end&#10;&#10;  # PATCH/PUT /tb_policies/1&#10;  def update&#10;    service = TbPolicyCreatorService.new(tb_policy_params, request.env[&quot;jwt.payload&quot;])&#10;&#10;    result = service.updateEntity(params[:id])&#10;&#10;    if result[:success]&#10;      render json: result[:tb_policy], status: :created&#10;    else&#10;      render json: { errors: result[:errors] }, status: :unprocessable_entity&#10;    end&#10;&#10;  end&#10;&#10;  # DELETE /tb_policies/1&#10;  def destroy&#10;    service = TbPolicyCreatorService.new({}, request.env[&quot;jwt.payload&quot;])&#10;&#10;    result = service.deleteById(params[:id])&#10;&#10;    if result[:success]&#10;      render json: { message: result[:message] }, status: :ok&#10;    else&#10;      render json: { errors: result[:errors] }, status: :unprocessable_entity&#10;    end&#10;  end&#10;&#10;end&#10;" />
              <option name="updatedContent" value="class TbPoliciesController &lt; ApplicationController&#10;&#10;  def tb_policy_params&#10;    params.require(:tb_policy).permit(:id, :policy_number, :tb_customer_id, :start_date, :end_date, :status, :created_at, :updated_at)&#10;  end&#10;&#10;  skip_before_action :verify_authenticity_token&#10;&#10;  before_action do&#10;    @token_service = TbTokenService.new(request)&#10;    @user_cpf = request.env[&quot;jwt.payload&quot;] &amp;&amp; request.env[&quot;jwt.payload&quot;][&quot;sub&quot;]&#10;&#10;    # Verificar se o token está expirado&#10;    if @token_service.token_expired?&#10;      render json: { error: &quot;Token expirado&quot; }, status: :unauthorized&#10;      return&#10;    end&#10;  end&#10;&#10;  before_action only: [:update, :destroy] do&#10;    unless @token_service.has_scope?([&quot;ADMIN_SCOPE&quot;])&#10;      render json: { error: &quot;Escopo insuficiente&quot; }, status: :forbidden&#10;      next&#10;    end&#10;  end&#10;&#10;  before_action only: [:create] do&#10;    unless @token_service.has_scope?(%w[ADMIN_SCOPE OPERATOR_SCOPE])&#10;      render json: { error: &quot;Escopo insuficiente&quot; }, status: :forbidden&#10;      next&#10;    end&#10;  end&#10;&#10;  def index&#10;    service = TbPolicyCreatorService.new({}, request.env[&quot;jwt.payload&quot;])&#10;&#10;    if @token_service.has_scope?([&quot;ADMIN_SCOPE&quot;, &quot;OPERATOR_SCOPE&quot;])&#10;      result = service.findAll&#10;    else&#10;      result = service.findAllById(@user_cpf)&#10;    end&#10;&#10;    if result[:success]&#10;      render json: result[:tb_policies], status: :ok&#10;    else&#10;      render json: { errors: result[:errors] }, status: :not_found&#10;    end&#10;  end&#10;&#10;# GET /tb_policies/1&#10;  def show&#10;    service = TbPolicyCreatorService.new({}, request.env[&quot;jwt.payload&quot;])&#10;&#10;    result = service.findById(params[:id])&#10;&#10;    if result[:success]&#10;      render json: result[:tb_policy], status: :ok&#10;    else&#10;      render json: { errors: result[:errors] }, status: :not_found&#10;    end&#10;  end&#10;&#10;  # POST /tb_policies&#10;  def create&#10;    service = TbPolicyCreatorService.new(tb_policy_params, request.env[&quot;jwt.payload&quot;])&#10;&#10;    result = service.saveEntity&#10;&#10;    if result[:success]&#10;      render json: result[:tb_policy], status: :created&#10;    else&#10;      render json: { errors: result[:errors] }, status: :unprocessable_entity&#10;    end&#10;  end&#10;&#10;  # PATCH/PUT /tb_policies/1&#10;  def update&#10;    service = TbPolicyCreatorService.new(tb_policy_params, request.env[&quot;jwt.payload&quot;])&#10;&#10;    result = service.updateEntity(params[:id])&#10;&#10;    if result[:success]&#10;      render json: result[:tb_policy], status: :created&#10;    else&#10;      render json: { errors: result[:errors] }, status: :unprocessable_entity&#10;    end&#10;&#10;  end&#10;&#10;  # DELETE /tb_policies/1&#10;  def destroy&#10;    service = TbPolicyCreatorService.new({}, request.env[&quot;jwt.payload&quot;])&#10;&#10;    result = service.deleteById(params[:id])&#10;&#10;    if result[:success]&#10;      render json: { message: result[:message] }, status: :ok&#10;    else&#10;      render json: { errors: result[:errors] }, status: :unprocessable_entity&#10;    end&#10;  end&#10;&#10;end" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/create_tb_customer_service.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/create_tb_customer_service.rb" />
              <option name="updatedContent" value="class CreateTbCustomerService&#10;  def initialize(params)&#10;    @params = params&#10;  end&#10;&#10;  def call&#10;    tb_customer = TbCustomers.new(@params)&#10;    tb_customer.createdAt = Time.now&#10;    tb_customer.updatedAt = Time.now&#10;    if tb_customer.save&#10;      { success: true, tb_customer: tb_customer }&#10;    else&#10;      { success: false, errors: tb_customer.errors }&#10;    end&#10;  end&#10;end&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/policies_service.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/policies_service.rb" />
              <option name="updatedContent" value="class PoliciesService&#10;  def self.all&#10;    TbPolicy.all&#10;  end&#10;&#10;  def self.find(id)&#10;    TbPolicy.find(id)&#10;  end&#10;&#10;  def self.create(params)&#10;    TbPolicy.create(params)&#10;  end&#10;&#10;  def self.update(policy, params)&#10;    policy.update(params)&#10;  end&#10;&#10;  def self.destroy(policy)&#10;    policy.destroy&#10;  end&#10;end&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/tb_policy_creator_service.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/tb_policy_creator_service.rb" />
              <option name="originalContent" value="# app/services/tb_policy_creator_service.rb&#10;class TbPolicyCreatorService&#10;  def initialize(params, payload)&#10;    @params = params&#10;    @payload = payload&#10;  end&#10;&#10;  def updateEntity(id)&#10;    tbcustomer = TbCustomers.find_by(id: @payload[&quot;sub&quot;])&#10;&#10;    tb_policy = TbPolicy.find_by(id: id)&#10;    unless tb_policy&#10;      return { success: false, errors: [&quot;TbPolicy não encontrado para o ID informado.&quot;] }&#10;    end&#10;&#10;    unless tbcustomer&#10;      return { success: false, errors: [&quot;Cliente não encontrado para o ID informado.&quot;] }&#10;    end&#10;&#10;    if @params[:policy_number] &amp;&amp; @params[:policy_number].to_s.length != 12&#10;      return { success: false, errors: [&quot;O policy_number deve ter exatamente 12 dígitos.&quot;] }&#10;    end&#10;&#10;    tb_policy.policy_number = @params[&quot;policy_number&quot;]&#10;    tb_policy.tb_customer_id = @params[&quot;tb_customer_id&quot;]&#10;    tb_policy.start_date = @params[:start_date]&#10;    tb_policy.end_date = @params[:end_date]&#10;    tb_policy.status = @params[:status]&#10;    tb_policy.updated_at = Time.now&#10;&#10;    if tb_policy.save&#10;      { success: true, tb_policy: tb_policy }&#10;    else&#10;      { success: false, errors: tb_policy.errors.full_messages }&#10;    end&#10;  end&#10;&#10;  def findById(id)&#10;    @tb_policy = TbPolicy.find_by(id: id)&#10;&#10;    if @tb_policy.nil?&#10;      return { success: false, errors: [&quot;Police não encontrado para o ID informado.&quot;] }&#10;    end&#10;&#10;    # Verificar se o usuário tem permissão para acessar esta policy&#10;    user_scopes = @payload &amp;&amp; @payload[&quot;scope&quot;].to_s.split&#10;    user_cpf = @payload &amp;&amp; @payload[&quot;sub&quot;]&#10;&#10;    if user_scopes &amp;&amp; (user_scopes.include?(&quot;ADMIN_SCOPE&quot;) || user_scopes.include?(&quot;OPERATOR_SCOPE&quot;)) || @tb_policy.tb_customer_id == user_cpf&#10;      { success: true, tb_policy: @tb_policy }&#10;    else&#10;      { success: false, errors: [&quot;Acesso negado.&quot;] }&#10;    end&#10;  end&#10;&#10;  def saveEntity&#10;    puts &quot;ID recebido do payload: &quot;, @payload[&quot;sub&quot;]&#10;    tbcustomer = TbCustomers.find_by(id: @payload[&quot;sub&quot;])&#10;    puts &quot;Resultado da busca do cliente: &quot;, tbcustomer.inspect&#10;&#10;    unless tbcustomer&#10;      return { success: false, errors: [&quot;Cliente não encontrado para o ID informado.&quot;] }&#10;    end&#10;&#10;    tb_policy = TbPolicy.new(@params)&#10;&#10;    tb_policy.id = SecureRandom.uuid&#10;    tb_policy.policy_number = SecureRandom.random_number(10**12).to_s.rjust(12, '0')&#10;    tb_policy.tb_customer_id = @payload[&quot;sub&quot;]&#10;    tb_policy.start_date = @params[:start_date]&#10;    tb_policy.end_date = @params[:end_date]&#10;    tb_policy.status = @params[:status]&#10;    tb_policy.created_at = Time.now&#10;    tb_policy.updated_at = Time.now&#10;&#10;    res = tb_policy.save&#10;    unless res&#10;      puts &quot;Erros ao salvar TbPolicy: #{tb_policy.errors.full_messages.inspect}&quot;&#10;    end&#10;&#10;    if res&#10;      puts &quot;INSERT realizado na base para TbPolicy: #{tb_policy.inspect}&quot;&#10;      { success: true, tb_policy: tb_policy }&#10;    else&#10;      { success: false, errors: tb_policy.errors.full_messages }&#10;    end&#10;  end&#10;&#10;  def findAll(id = nil)&#10;    @tb_policies = TbPolicy.all&#10;    { success: true, tb_policies: @tb_policies }&#10;  end&#10;&#10;  def findAllById(customer_id)&#10;    @tb_policies = TbPolicy.where(tb_customer_id: customer_id)&#10;    { success: true, tb_policies: @tb_policies }&#10;  end&#10;&#10;end&#10;" />
              <option name="updatedContent" value="# app/services/tb_policy_creator_service.rb&#10;class TbPolicyCreatorService&#10;  def initialize(params, payload)&#10;    @params = params&#10;    @payload = payload&#10;  end&#10;&#10;  def updateEntity(id)&#10;    tbcustomer = TbCustomers.find_by(id: @payload[&quot;sub&quot;])&#10;&#10;    tb_policy = TbPolicy.find_by(id: id)&#10;    unless tb_policy&#10;      return { success: false, errors: [&quot;TbPolicy não encontrado para o ID informado.&quot;] }&#10;    end&#10;&#10;    unless tbcustomer&#10;      return { success: false, errors: [&quot;Cliente não encontrado para o ID informado.&quot;] }&#10;    end&#10;&#10;    if @params[:policy_number] &amp;&amp; @params[:policy_number].to_s.length != 12&#10;      return { success: false, errors: [&quot;O policy_number deve ter exatamente 12 dígitos.&quot;] }&#10;    end&#10;&#10;    tb_policy.policy_number = @params[&quot;policy_number&quot;]&#10;    tb_policy.tb_customer_id = @params[&quot;tb_customer_id&quot;]&#10;    tb_policy.start_date = @params[:start_date]&#10;    tb_policy.end_date = @params[:end_date]&#10;    tb_policy.status = @params[:status]&#10;    tb_policy.updated_at = Time.now&#10;&#10;    if tb_policy.save&#10;      { success: true, tb_policy: tb_policy }&#10;    else&#10;      { success: false, errors: tb_policy.errors.full_messages }&#10;    end&#10;  end&#10;&#10;  def findById(id)&#10;    @tb_policy = TbPolicy.find_by(id: id)&#10;&#10;    if @tb_policy.nil?&#10;      return { success: false, errors: [&quot;Police não encontrado para o ID informado.&quot;] }&#10;    end&#10;&#10;    # Verificar se o usuário tem permissão para acessar esta policy&#10;    user_scopes = @payload &amp;&amp; @payload[&quot;scope&quot;].to_s.split&#10;    user_cpf = @payload &amp;&amp; @payload[&quot;sub&quot;]&#10;&#10;    if user_scopes &amp;&amp; (user_scopes.include?(&quot;ADMIN_SCOPE&quot;) || user_scopes.include?(&quot;OPERATOR_SCOPE&quot;)) || @tb_policy.tb_customer_id == user_cpf&#10;      { success: true, tb_policy: @tb_policy }&#10;    else&#10;      { success: false, errors: [&quot;Acesso negado.&quot;] }&#10;    end&#10;  end&#10;&#10;  def saveEntity&#10;    puts &quot;ID recebido do payload: &quot;, @payload[&quot;sub&quot;]&#10;    tbcustomer = TbCustomers.find_by(id: @payload[&quot;sub&quot;])&#10;    puts &quot;Resultado da busca do cliente: &quot;, tbcustomer.inspect&#10;&#10;    unless tbcustomer&#10;      return { success: false, errors: [&quot;Cliente não encontrado para o ID informado.&quot;] }&#10;    end&#10;&#10;    tb_policy = TbPolicy.new(@params)&#10;&#10;    tb_policy.id = SecureRandom.uuid&#10;    tb_policy.policy_number = SecureRandom.random_number(10**12).to_s.rjust(12, '0')&#10;    tb_policy.tb_customer_id = @payload[&quot;sub&quot;]&#10;    tb_policy.start_date = @params[:start_date]&#10;    tb_policy.end_date = @params[:end_date]&#10;    tb_policy.status = @params[:status]&#10;    tb_policy.created_at = Time.now&#10;    tb_policy.updated_at = Time.now&#10;&#10;    res = tb_policy.save&#10;    unless res&#10;      puts &quot;Erros ao salvar TbPolicy: #{tb_policy.errors.full_messages.inspect}&quot;&#10;    end&#10;&#10;    if res&#10;      puts &quot;INSERT realizado na base para TbPolicy: #{tb_policy.inspect}&quot;&#10;      { success: true, tb_policy: tb_policy }&#10;    else&#10;      { success: false, errors: tb_policy.errors.full_messages }&#10;    end&#10;  end&#10;&#10;  def findAll(id = nil)&#10;    @tb_policies = TbPolicy.all&#10;    { success: true, tb_policies: @tb_policies }&#10;  end&#10;&#10;  def findAllById(customer_id)&#10;    @tb_policies = TbPolicy.where(tb_customer_id: customer_id)&#10;    { success: true, tb_policies: @tb_policies }&#10;  end&#10;&#10;  def deleteById(id)&#10;    @tb_policy = TbPolicy.find_by(id: id)&#10;&#10;    if @tb_policy.nil?&#10;      return { success: false, errors: [&quot;Policy não encontrado para o ID informado.&quot;] }&#10;    end&#10;&#10;    # Verificar se o usuário tem permissão para deletar esta policy&#10;    user_scopes = @payload &amp;&amp; @payload[&quot;scope&quot;].to_s.split&#10;    user_cpf = @payload &amp;&amp; @payload[&quot;sub&quot;]&#10;    &#10;    # Apenas ADMIN_SCOPE pode deletar policies&#10;    unless user_scopes &amp;&amp; user_scopes.include?(&quot;ADMIN_SCOPE&quot;)&#10;      return { success: false, errors: [&quot;Apenas administradores podem deletar policies.&quot;] }&#10;    end&#10;&#10;    if @tb_policy.destroy&#10;      { success: true, message: &quot;Policy deletado com sucesso.&quot; }&#10;    else&#10;      { success: false, errors: @tb_policy.errors.full_messages }&#10;    end&#10;  end&#10;&#10;end" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/tb_token_service.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/tb_token_service.rb" />
              <option name="originalContent" value="class TbTokenService&#10;  def initialize(request)&#10;    @request = request&#10;  end&#10;&#10;  def check_token_expiration&#10;    payload = @request.env[&quot;jwt.payload&quot;]&#10;    if payload &amp;&amp; payload[&quot;exp&quot;] &amp;&amp; Time.at(payload[&quot;exp&quot;]) &lt; Time.now&#10;      raise &quot;Token expirado&quot;&#10;    end&#10;  end&#10;&#10;  def has_scope?(scopes)&#10;    check_token_expiration&#10;&#10;    payload = @request.env[&quot;jwt.payload&quot;]&#10;    user_scopes = payload &amp;&amp; payload[&quot;scope&quot;].to_s.split&#10;    return false unless user_scopes &amp;&amp; scopes.is_a?(Array)&#10;    (user_scopes &amp; scopes).any?&#10;  end&#10;&#10;end&#10;" />
              <option name="updatedContent" value="class TbTokenService&#10;  def initialize(request)&#10;    @request = request&#10;  end&#10;&#10;  def check_token_expiration&#10;    payload = @request.env[&quot;jwt.payload&quot;]&#10;    if payload &amp;&amp; payload[&quot;exp&quot;] &amp;&amp; Time.at(payload[&quot;exp&quot;]) &lt; Time.now&#10;      return false # Token expirado&#10;    end&#10;    true # Token válido&#10;  end&#10;&#10;  def has_scope?(scopes)&#10;    # Verificar se o token está expirado&#10;    unless check_token_expiration&#10;      return false # Se expirado, retorna false&#10;    end&#10;&#10;    payload = @request.env[&quot;jwt.payload&quot;]&#10;    user_scopes = payload &amp;&amp; payload[&quot;scope&quot;].to_s.split&#10;    return false unless user_scopes &amp;&amp; scopes.is_a?(Array)&#10;    (user_scopes &amp; scopes).any?&#10;  end&#10;&#10;  def token_expired?&#10;    payload = @request.env[&quot;jwt.payload&quot;]&#10;    if payload &amp;&amp; payload[&quot;exp&quot;] &amp;&amp; Time.at(payload[&quot;exp&quot;]) &lt; Time.now&#10;      return true&#10;    end&#10;    false&#10;  end&#10;end" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config/application.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config/application.rb" />
              <option name="originalContent" value="require_relative &quot;boot&quot;&#10;&#10;require &quot;rails/all&quot;&#10;&#10;# Require the gems listed in Gemfile, including any gems&#10;# you've limited to :test, :development, or :production.&#10;Bundler.require(*Rails.groups)&#10;&#10;module SegDevChallenge&#10;  class Application &lt; Rails::Application&#10;    # Initialize configuration defaults for originally generated Rails version.&#10;    config.load_defaults 8.0&#10;&#10;    # Please, add to the `ignore` list any other `lib` subdirectories that do&#10;    # not contain `.rb` files, or that should not be reloaded or eager loaded.&#10;    # Common ones are `templates`, `generators`, or `middleware`, for example.&#10;    config.autoload_lib(ignore: %w[assets tasks])&#10;&#10;    config.autoload_paths &lt;&lt; Rails.root.join('app', 'middleware')&#10;    config.middleware.use JwtAuthMiddleware&#10;&#10;    # Configuration for the application, engines, and railties goes here.&#10;    #&#10;    # These settings can be overridden in specific environments using the files&#10;    # in config/environments, which are processed later.&#10;    #&#10;    # config.time_zone = &quot;Central Time (US &amp; Canada)&quot;&#10;    # config.eager_load_paths &lt;&lt; Rails.root.join(&quot;extras&quot;)&#10;  end&#10;end&#10;" />
              <option name="updatedContent" value="require_relative &quot;boot&quot;&#10;&#10;require &quot;rails/all&quot;&#10;&#10;# Require the gems listed in Gemfile, including any gems&#10;# you've limited to :test, :development, or :production.&#10;Bundler.require(*Rails.groups)&#10;&#10;module SegDevChallenge&#10;  class Application &lt; Rails::Application&#10;    # Initialize configuration defaults for originally generated Rails version.&#10;    config.load_defaults 8.0&#10;&#10;    # Please, add to the `ignore` list any other `lib` subdirectories that do&#10;    # not contain `.rb` files, or that should not be reloaded or eager loaded.&#10;    # Common ones are `templates`, `generators`, or `middleware`, for example.&#10;    config.autoload_lib(ignore: %w[assets tasks])&#10;&#10;    require_relative '../app/middleware/jwt_auth_middleware'&#10;    config.autoload_paths &lt;&lt; Rails.root.join('app', 'middleware')&#10;    config.middleware.use JwtAuthMiddleware&#10;&#10;    # Configuration for the application, engines, and railties goes here.&#10;    #&#10;    # These settings can be overridden in specific environments using the files&#10;    # in config/environments, which are processed later.&#10;    #&#10;    # config.time_zone = &quot;Central Time (US &amp; Canada)&quot;&#10;    # config.eager_load_paths &lt;&lt; Rails.root.join(&quot;extras&quot;)&#10;  end&#10;end" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config/database.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config/database.yml" />
              <option name="originalContent" value="# SQLite. Versions 3.8.0 and up are supported.&#10;#   gem install sqlite3&#10;#&#10;#   Ensure the SQLite 3 gem is defined in your Gemfile&#10;#   gem &quot;sqlite3&quot;&#10;#&#10;default: &amp;default&#10;  adapter: sqlite3&#10;  pool: &lt;%= ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) { 5 } %&gt;&#10;  timeout: 5000&#10;&#10;development:&#10;  &lt;&lt;: *default&#10;  adapter: postgresql&#10;  encoding: unicode&#10;  host: localhost&#10;  username: postgres&#10;  password: postgres&#10;  database: postgres&#10;&#10;# Warning: The database defined as &quot;test&quot; will be erased and&#10;# re-generated from your development database when you run &quot;rake&quot;.&#10;# Do not set this db to the same as development or production.&#10;test:&#10;  &lt;&lt;: *default&#10;  database: storage/test.sqlite3&#10;&#10;&#10;# Store production database in the storage/ directory, which by default&#10;# is mounted as a persistent Docker volume in config/deploy.yml.&#10;production:&#10;  primary:&#10;    &lt;&lt;: *default&#10;    database: storage/production.sqlite3&#10;  cache:&#10;    &lt;&lt;: *default&#10;    database: storage/production_cache.sqlite3&#10;    migrations_paths: db/cache_migrate&#10;  queue:&#10;    &lt;&lt;: *default&#10;    database: storage/production_queue.sqlite3&#10;    migrations_paths: db/queue_migrate&#10;  cable:&#10;    &lt;&lt;: *default&#10;    database: storage/production_cable.sqlite3&#10;    migrations_paths: db/cable_migrate&#10;" />
              <option name="updatedContent" value="# SQLite. Versions 3.8.0 and up are supported.&#10;#   gem install sqlite3&#10;#&#10;#   Ensure the SQLite 3 gem is defined in your Gemfile&#10;#   gem &quot;sqlite3&quot;&#10;#&#10;default: &amp;default&#10;  adapter: sqlite3&#10;  pool: &lt;%= ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) { 5 } %&gt;&#10;  timeout: 5000&#10;&#10;development:&#10;  &lt;&lt;: *default&#10;  adapter: postgresql&#10;  encoding: unicode&#10;  host: &lt;%= ENV['DOCKERENV'] ? 'postgres' : 'localhost' %&gt;&#10;  username: postgres&#10;  password: postgres&#10;  database: postgres&#10;&#10;# Warning: The database defined as &quot;test&quot; will be erased and&#10;# re-generated from your development database when you run &quot;rake&quot;.&#10;# Do not set this db to the same as development or production.&#10;test:&#10;  &lt;&lt;: *default&#10;  database: storage/test.sqlite3&#10;&#10;&#10;# Store production database in the storage/ directory, which by default&#10;# is mounted as a persistent Docker volume in config/deploy.yml.&#10;production:&#10;  primary:&#10;    &lt;&lt;: *default&#10;    database: storage/production.sqlite3&#10;  cache:&#10;    &lt;&lt;: *default&#10;    database: storage/production_cache.sqlite3&#10;    migrations_paths: db/cache_migrate&#10;  queue:&#10;    &lt;&lt;: *default&#10;    database: storage/production_queue.sqlite3&#10;    migrations_paths: db/queue_migrate&#10;  cable:&#10;    &lt;&lt;: *default&#10;    database: storage/production_cable.sqlite3&#10;    migrations_paths: db/cable_migrate" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config/environments/development.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config/environments/development.rb" />
              <option name="originalContent" value="require &quot;active_support/core_ext/integer/time&quot;&#10;&#10;Rails.application.configure do&#10;  # Settings specified here will take precedence over those in config/application.rb.&#10;&#10;  config.active_record.migration_error = false&#10;&#10;  # Make code changes take effect immediately without server restart.&#10;  config.enable_reloading = true&#10;&#10;  # Do not eager load code on boot.&#10;  config.eager_load = false&#10;&#10;  # Show full error reports.&#10;  config.consider_all_requests_local = true&#10;&#10;  # Enable server timing.&#10;  config.server_timing = true&#10;&#10;  # Enable/disable Action Controller caching. By default Action Controller caching is disabled.&#10;  # Run rails dev:cache to toggle Action Controller caching.&#10;  if Rails.root.join(&quot;tmp/caching-dev.txt&quot;).exist?&#10;    config.action_controller.perform_caching = true&#10;    config.action_controller.enable_fragment_cache_logging = true&#10;    config.public_file_server.headers = { &quot;cache-control&quot; =&gt; &quot;public, max-age=#{2.days.to_i}&quot; }&#10;  else&#10;    config.action_controller.perform_caching = false&#10;  end&#10;&#10;  # Change to :null_store to avoid any caching.&#10;  config.cache_store = :memory_store&#10;&#10;  # Store uploaded files on the local file system (see config/storage.yml for options).&#10;  config.active_storage.service = :local&#10;&#10;  # Don't care if the mailer can't send.&#10;  config.action_mailer.raise_delivery_errors = false&#10;&#10;  # Make template changes take effect immediately.&#10;  config.action_mailer.perform_caching = false&#10;&#10;  # Set localhost to be used by links generated in mailer templates.&#10;  config.action_mailer.default_url_options = { host: &quot;localhost&quot;, port: 3000 }&#10;&#10;  # Print deprecation notices to the Rails logger.&#10;  config.active_support.deprecation = :log&#10;&#10;  # Raise an error on page load if there are pending migrations.&#10;  config.active_record.migration_error = :page_load&#10;&#10;  # Highlight code that triggered database queries in logs.&#10;  config.active_record.verbose_query_logs = true&#10;&#10;  # Append comments with runtime information tags to SQL queries in logs.&#10;  config.active_record.query_log_tags_enabled = true&#10;&#10;  # Highlight code that enqueued background job in logs.&#10;  config.active_job.verbose_enqueue_logs = true&#10;&#10;  # Raises error for missing translations.&#10;  # config.i18n.raise_on_missing_translations = true&#10;&#10;  # Annotate rendered view with file names.&#10;  config.action_view.annotate_rendered_view_with_filenames = true&#10;&#10;  # Uncomment if you wish to allow Action Cable access from any origin.&#10;  # config.action_cable.disable_request_forgery_protection = true&#10;&#10;  # Raise error when a before_action's only/except options reference missing actions.&#10;  config.action_controller.raise_on_missing_callback_actions = true&#10;&#10;  # Apply autocorrection by RuboCop to files generated by `bin/rails generate`.&#10;  # config.generators.apply_rubocop_autocorrect_after_generate!&#10;&#10;  Rails.logger = Logger.new(STDOUT)&#10;  ActiveRecord::Base.logger = Rails.logger&#10;end&#10;" />
              <option name="updatedContent" value="require &quot;active_support/core_ext/integer/time&quot;&#10;&#10;Rails.application.configure do&#10;  # Settings specified here will take precedence over those in config/application.rb.&#10;&#10;  # Disable migration check since we use custom SQL script&#10;  config.active_record.migration_error = false&#10;&#10;  # Make code changes take effect immediately without server restart.&#10;  config.enable_reloading = true&#10;&#10;  # Do not eager load code on boot.&#10;  config.eager_load = false&#10;&#10;  # Show full error reports.&#10;  config.consider_all_requests_local = true&#10;&#10;  # Enable server timing.&#10;  config.server_timing = true&#10;&#10;  # Enable/disable Action Controller caching. By default Action Controller caching is disabled.&#10;  # Run rails dev:cache to toggle Action Controller caching.&#10;  if Rails.root.join(&quot;tmp/caching-dev.txt&quot;).exist?&#10;    config.action_controller.perform_caching = true&#10;    config.action_controller.enable_fragment_cache_logging = true&#10;    config.public_file_server.headers = { &quot;cache-control&quot; =&gt; &quot;public, max-age=#{2.days.to_i}&quot; }&#10;  else&#10;    config.action_controller.perform_caching = false&#10;  end&#10;&#10;  # Change to :null_store to avoid any caching.&#10;  config.cache_store = :memory_store&#10;&#10;  # Store uploaded files on the local file system (see config/storage.yml for options).&#10;  config.active_storage.service = :local&#10;&#10;  # Don't care if the mailer can't send.&#10;  config.action_mailer.raise_delivery_errors = false&#10;&#10;  # Make template changes take effect immediately.&#10;  config.action_mailer.perform_caching = false&#10;&#10;  # Set localhost to be used by links generated in mailer templates.&#10;  config.action_mailer.default_url_options = { host: &quot;localhost&quot;, port: 3000 }&#10;&#10;  # Print deprecation notices to the Rails logger.&#10;  config.active_support.deprecation = :log&#10;&#10;  # Raise exceptions for disallowed deprecations.&#10;  config.active_support.disallowed_deprecation = :raise&#10;&#10;  # Tell Active Support which deprecation messages to disallow.&#10;  config.active_support.disallowed_deprecation_warnings = []&#10;&#10;  # Disable migration check - we use custom SQL script (commented out the original line)&#10;  # config.active_record.migration_error = :page_load&#10;&#10;  # Highlight code that triggered database queries in logs.&#10;  config.active_record.verbose_query_logs = true&#10;&#10;  # Append comments with runtime information tags to SQL queries in logs.&#10;  config.active_record.query_log_tags_enabled = true&#10;&#10;  # Highlight code that enqueued background job in logs.&#10;  config.active_job.verbose_enqueue_logs = true&#10;&#10;  # Raises error for missing translations.&#10;  # config.i18n.raise_on_missing_translations = true&#10;&#10;  # Annotate rendered view with file names.&#10;  config.action_view.annotate_rendered_view_with_filenames = true&#10;&#10;  # Uncomment if you wish to allow Action Cable access from any origin.&#10;  # config.action_cable.disable_request_forgery_protection = true&#10;&#10;  # Raise error when a before_action's only/except options reference missing actions.&#10;  config.action_controller.raise_on_missing_callback_actions = true&#10;&#10;  # Apply autocorrection by RuboCop to files generated by `bin/rails generate`.&#10;  # config.generators.apply_rubocop_autocorrect_after_generate!&#10;&#10;  Rails.logger = Logger.new(STDOUT)&#10;  ActiveRecord::Base.logger = Rails.logger&#10;end" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/db/migrate/20250730180000_rename_created_at_and_updated_at_in_tb_customers.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/db/migrate/20250730180000_rename_created_at_and_updated_at_in_tb_customers.rb" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docker-compose.yaml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docker-compose.yaml" />
              <option name="originalContent" value="services:&#10;&#10;  postgres:&#10;    container_name: postgres&#10;    image: postgres:15-alpine&#10;    restart: always&#10;    ports:&#10;      - &quot;5432:5432&quot;&#10;    environment:&#10;      POSTGRES_USER: postgres&#10;      POSTGRES_PASSWORD: postgres&#10;      POSTGRES_DB: postgres&#10;    volumes:&#10;      - postgres_data:/var/lib/postgresql/data&#10;      - ./init.sql:/docker-entrypoint-initdb.d/init.sql&#10;    networks:&#10;      - internal-network&#10;&#10;  adminer:&#10;    image: adminer&#10;    container_name: adminer&#10;    restart: always&#10;    ports:&#10;      - &quot;5400:8080&quot;&#10;    depends_on:&#10;      - postgres&#10;    environment:&#10;      ADMINER_DEFAULT_SERVER: postgres&#10;    networks:&#10;      - internal-network&#10;&#10;  ruby_app:&#10;    container_name: ruby_app&#10;    build: .&#10;    restart: always&#10;    working_dir: /app&#10;    ports:&#10;      - &quot;3000:3000&quot;&#10;    volumes:&#10;      - ./:/app&#10;    environment:&#10;      - DOCKERENV=true&#10;      - RAILS_ENV=development&#10;    depends_on:&#10;      - postgres&#10;    networks:&#10;      - internal-network&#10;&#10;networks:&#10;  internal-network:&#10;    driver: bridge&#10;&#10;volumes:&#10;  postgres_data:" />
              <option name="updatedContent" value="services:&#10;&#10;  postgres:&#10;    container_name: postgres&#10;    image: postgres:15-alpine&#10;    restart: always&#10;    ports:&#10;      - &quot;5432:5432&quot;&#10;    environment:&#10;      POSTGRES_USER: postgres&#10;      POSTGRES_PASSWORD: postgres&#10;      POSTGRES_DB: postgres&#10;    volumes:&#10;      - postgres_data:/var/lib/postgresql/data&#10;      - ./init.sql:/docker-entrypoint-initdb.d/init.sql&#10;    networks:&#10;      - internal-network&#10;&#10;  adminer:&#10;    image: adminer&#10;    container_name: adminer&#10;    restart: always&#10;    ports:&#10;      - &quot;5400:8080&quot;&#10;    depends_on:&#10;      - postgres&#10;    environment:&#10;      ADMINER_DEFAULT_SERVER: postgres&#10;    networks:&#10;      - internal-network&#10;&#10;  ruby_app:&#10;    container_name: ruby_app&#10;    build: .&#10;    restart: always&#10;    working_dir: /app&#10;    ports:&#10;      - &quot;3000:3000&quot;&#10;    volumes:&#10;      - ./:/app&#10;    environment:&#10;      - DOCKERENV=true&#10;      - RAILS_ENV=development&#10;    depends_on:&#10;      - postgres&#10;    networks:&#10;      - internal-network&#10;&#10;networks:&#10;  internal-network:&#10;    driver: bridge&#10;&#10;volumes:&#10;  postgres_data:" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>